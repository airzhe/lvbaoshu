<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <!-- Title will be set by JavaScript -->
    <title>å˜èªç·´ç¿’</title>
    <!--
    <script src="./tailwind.css"></script>
    -->

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* === ä¸»é¢˜é¢œè‰²å’ŒèƒŒæ™¯ === */
            --body-bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --body-text-color: #2d3748;
            /* åŸºç¡€æ–‡æœ¬é¢œè‰² (æ·±ç°ï¼ŒTailwind gray-800 ç±»ä¼¼) */
            --container-bg: rgba(255, 255, 255, 0.95);
            --container-border-color: rgba(255, 255, 255, 0.2);
            --container-text-color: inherit;
            /* ç»§æ‰¿ body æˆ–ç‰¹å®šé¢œè‰² */


            --controls-bg-white-override: initial;

            --gradient-text-bg: linear-gradient(45deg, #667eea, #764ba2);

            --btn-before-bg: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);

            --exit-btn-bg: linear-gradient(to bottom right, #e5e7eb, #d1d5db);
            --exit-btn-text-color: #374151;
            --exit-btn-hover-bg: linear-gradient(to bottom right, #d1d5db, #b3b7c1);

            --progress-bar-bg: #e9d5ff;
            /* æµ…è‰²æ¨¡å¼è¿›åº¦æ¡èƒŒæ™¯ (Tailwind purple-200 ç±»ä¼¼) */
            --progress-fill-bg: linear-gradient(to right, #3b82f6, #8b5cf6);

            --option-bg: rgba(255, 255, 255, 0.8);
            --option-border-color: #93c5fd;
            /* Tailwind blue-300 */
            --option-text-color: inherit;
            --option-hover-bg: rgba(239, 246, 255, 0.95);
            --option-hover-border-color: #818cf8;
            --option-hover-text-color: var(--text-body);

            --feedback-text-color-default: #374151;
            /* Tailwind gray-700 */

            --text-green-600-val: #059669;
            --text-red-600-val: #dc2626;
            --text-red-500-val: #ef4444;
            --text-orange-500-val: #f97316;
            --text-gray-900-val: #111827;
            --text-color-example-sentence-val: #4b5563;
            /* Tailwind gray-700 */

            --glass-morphism-bg: rgba(233, 236, 241, 0.6);
            /* Tailwind gray-100 with opacity (for .features bg-indigo-100) */
            --glass-morphism-border: 1px solid rgba(229, 231, 235, 0.5);
            /* Tailwind gray-200 with opacity */
            --glass-morphism-header-text: #4f46e5;
            /* Tailwind indigo-600 for .features h3 */

            /* åé¦ˆç‰¹å®šé¢œè‰² (æµ…è‰²) */
            --feedback-green-text: var(--text-green-600-val);
            --feedback-green-bg: rgba(220, 252, 231, 0.9);
            /* Tailwind green-100, more opaque */
            --feedback-green-border: rgba(110, 231, 183, 0.7);
            /* Tailwind green-300, more opaque */
            --feedback-green-shadow: 0 4px 12px rgba(52, 211, 153, 0.15);

            --feedback-red-text: var(--text-red-600-val);
            --feedback-red-bg: rgba(254, 226, 226, 0.9);
            /* Tailwind red-100, more opaque */
            --feedback-red-border: rgba(252, 165, 165, 0.7);
            /* Tailwind red-300, more opaque */
            --feedback-red-shadow: 0 4px 12px rgba(248, 113, 113, 0.15);

            --immersive-quiz-container-bg: rgba(255, 255, 255, 0.25);
            /* from your original */
        }

        body.dark-mode {
            --body-bg-gradient: linear-gradient(135deg, #1a2634 0%, #2c3e50 100%);
            --body-text-color: #e2e8f0;
            /* Tailwind slate-200 */
            --container-bg: rgba(45, 55, 72, 0.95);
            /* Tailwind slate-700 */
            --container-border-color: rgba(255, 255, 255, 0.3);
            --container-text-color: #e2e8f0;

            --controls-bg-white-override: rgba(255, 255, 255, 0.1);

            /* --gradient-text-bg: linear-gradient(45deg, #93c5fd, #c4b5fd); */

            --btn-before-bg: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);

            --exit-btn-bg: linear-gradient(to bottom right, #4b5563, #6b7280);
            --exit-btn-text-color: #e2e8f0;
            --exit-btn-hover-bg: linear-gradient(to bottom right, #6b7280, #9ca3af);

            --progress-bar-bg: #4b5563;
            /* Tailwind gray-600 */
            /* --progress-fill-bg: linear-gradient(to right, #3b82f6, #8b5cf6); /* ä¿æŒä¸å˜æˆ–æŒ‰éœ€ä¿®æ”¹ */

            --option-bg: rgba(55, 65, 81, 0.8);
            /* Tailwind gray-700 */
            --option-border-color: #60a5fa;
            /* Tailwind blue-400 */
            --option-text-color: #e2e8f0;
            --option-hover-bg: rgba(69, 71, 90, 0.9);
            /* ä¾‹å¦‚ï¼šCatppuccin Surface1ï¼Œæ¯”åŸºç¡€èƒŒæ™¯ç¨äº® */
            --option-hover-border-color: #89b4fa;
            --option-hover-text-color: var(--text-body);

            --text-green-600-val: #34d399;
            --text-red-600-val: #f87171;
            /* Note: original was text-red-600, but value seems for text-red-400/500 */
            --text-red-500-val: #f87171;
            --text-orange-500-val: #fb923c;
            --text-gray-900-val: #e2e8f0;
            --text-color-example-sentence-val: #cbd5e1;
            /* Tailwind slate-300 */

            --glass-morphism-bg: rgba(45, 55, 72, 0.6);
            /* Tailwind slate-700 with opacity (for .features dark:bg-indigo-900 dark:bg-opacity-40) */
            --glass-morphism-border: 1px solid rgba(255, 255, 255, 0.15);
            --glass-morphism-header-text: #818cf8;
            /* Tailwind indigo-400 for .features h3 dark:text-indigo-400 */

            /* åé¦ˆç‰¹å®šé¢œè‰² (æ·±è‰²) */
            --feedback-green-text: #6ee7b7;
            --feedback-green-bg: rgba(16, 185, 129, 0.8);
            --feedback-green-border: rgba(52, 211, 153, 0.5);
            --feedback-green-shadow: 0 4px 12px rgba(52, 211, 153, 0.25);

            --feedback-red-text: #fca5a5;
            --feedback-red-bg: rgba(220, 38, 38, 0.8);
            --feedback-red-border: rgba(248, 113, 113, 0.5);
            --feedback-red-shadow: 0 4px 12px rgba(248, 113, 113, 0.25);

            --immersive-quiz-container-bg: rgba(30, 41, 59, 0.6);
            /* dark variant of your original, slate-800 like*/

        }

        /* --- åŸºç¡€å’Œç»„ä»¶æ ·å¼ --- */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background: var(--body-bg-gradient);
            color: var(--body-text-color);
            transition: background 0.5s ease, color 0.5s ease;
            overscroll-behavior-y: contain;
        }

        .header,
        .controls,
        .quiz-container:not(.immersive-active) {
            /* Exclude immersive for its own bg */
            background: var(--container-bg);
            /* border-color: var(--container-border-color); Apply if these elements have a border styled e.g., border: 1px solid; */
            color: var(--container-text-color);
        }

        body.dark-mode .controls .bg-white {
            /* Handles Tailwind .bg-white inside .controls */
            background: var(--controls-bg-white-override) !important;
            /* Important if .bg-white has high specificity */
        }

        .gradient-text {
            background: var(--gradient-text-bg);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--btn-before-bg);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .exit-btn {
            position: absolute;
            top: calc(env(safe-area-inset-top, 0px) + 0.75rem);
            right: 0.75rem;
            width: 2.5rem;
            height: 2.5rem;
            background: var(--exit-btn-bg);
            color: var(--exit-btn-text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease, color 0.3s ease, transform 0.3s ease;
            z-index: 50;
        }

        .exit-btn:hover {
            background: var(--exit-btn-hover-bg);
            transform: scale(1.05);
        }

        .exit-btn:active {
            transform: scale(0.95);
        }

        .theme-toggle {
            z-index: 50;
            /* Base styles for theme-toggle if not covered by Tailwind and needed here */
        }

        body.quiz-mode-active .theme-toggle {
            display: none !important;
        }

        .progress-bar {
            background: var(--progress-bar-bg);
            width: 100%;
            height: 0.625rem;
            /* 2.5 in Tailwind, h-2.5 */
            border-radius: 0.375rem;
            /* rounded-md */
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            background: var(--progress-fill-bg);
            height: 100%;
            border-radius: 0.375rem;
            /* rounded-md */
            transition: width 0.5s ease-in-out;
            /* width comes from JS style */
            position: relative;
            /* For ::after positioning */
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image: linear-gradient(-45deg,
                    rgba(255, 255, 255, 0.2) 25%,
                    transparent 25%,
                    transparent 50%,
                    rgba(255, 255, 255, 0.2) 50%,
                    rgba(255, 255, 255, 0.2) 75%,
                    transparent 75%,
                    transparent);
            background-size: 30px 30px;
            animation: move 2s linear infinite;
        }

        @keyframes move {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 30px 30px;
            }
        }

        .option {
            position: relative;
            overflow: hidden;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            background: var(--option-bg);
            border-color: var(--option-border-color);
            /* Needs 'border-width' and 'border-style' to be visible */
            color: var(--option-text-color);
            /* Ensure other Tailwind classes like p-*, rounded-*, border-2 are on the HTML element */
        }

        @media (hover: hover) and (pointer: fine) {
            .option:hover:not(:disabled) {
                background-color: var(--option-hover-bg);
                border-color: var(--option-hover-border-color);
                color: var(--option-hover-text-color);
            }
        }

        .option.selected-option {
            border-width: 2px;
            /* This makes the border visible if other border properties are set */
        }

        /* æ–°å¢: ç¦ç”¨é€‰é¡¹çš„æ ·å¼ */
        .option:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }


        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes incorrectShake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-4px);
            }

            75% {
                transform: translateX(4px);
            }
        }

        body.quiz-mode-active .container {
            padding: 0;
            max-width: 100%;
            height: 100dvh;
            /* Use dvh for dynamic viewport height */
            display: flex;
        }

        #quizContainer.immersive-active {
            width: 100%;
            height: 100dvh;
            min-height: 100dvh;
            margin: 0 !important;
            border-radius: 0;
            box-shadow: none;
            padding-top: calc(env(safe-area-inset-top, 0px) + 1.5rem) !important;
            padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 0.5rem) !important;
            padding-left: 1rem !important;
            padding-right: 1rem !important;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            position: relative;
            background: var(--immersive-quiz-container-bg);
        }

        #quizContainer.immersive-active>div:not(.progress-container):not(.stats):not(.options):not(.feedback):not(.question-area-wrapper) {
            flex-grow: 1;
        }

        #quizContainer.immersive-active .question-area-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding-top: 5.5rem;
            align-items: center;
        }

        #quizContainer.immersive-active .question-content-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #quizContainer.immersive-active .options {
            margin-top: auto;
            padding-bottom: 2rem;
            width: 100%;
        }

        #quizContainer.immersive-active .feedback {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 1.5rem);
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            margin-top: 0;
            margin-bottom: 0;
            z-index: 100;
            visibility: hidden;
            /* Controlled by JS */
        }

        .header.hidden-during-quiz,
        .controls.hidden-during-quiz {
            display: none !important;
        }

        .feedback {
            text-align: center;
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.2s ease-out;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            word-break: break-word;
            color: var(--feedback-text-color-default);
            /* Other base styles for feedback like padding, border-radius if not handled by Tailwind */
        }

        /* Assumes JS adds 'text-green-600' or 'text-red-600' for feedback states */
        .feedback.text-green-600 {
            color: var(--feedback-green-text) !important;
            /* Important to override Tailwind if needed */
            background-color: var(--feedback-green-bg);
            border-color: var(--feedback-green-border);
            /* Needs border-width and style */
            box-shadow: var(--feedback-green-shadow);
        }

        .feedback.text-red-600 {
            color: var(--feedback-red-text) !important;
            /* Important to override Tailwind if needed */
            background-color: var(--feedback-red-bg);
            border-color: var(--feedback-red-border);
            /* Needs border-width and style */
            box-shadow: var(--feedback-red-shadow);
        }

        /* For .features div in welcome message */
        .features.glass-morphism {
            background: var(--glass-morphism-bg);
            border: var(--glass-morphism-border);
            /* color for text inside .features.glass-morphism ul li can inherit or be set */
        }

        .features.glass-morphism h3 {
            color: var(--glass-morphism-header-text);
        }


        .feedback small {
            display: block;
            margin-top: 0.5rem;
            line-height: 1.4;
            /* color for small text can also be a variable */
        }

        /* Stats colors - these override Tailwind text color classes in dark mode */
        body.dark-mode .stats .score.text-green-600 {
            color: var(--text-green-600-val) !important;
        }

        body.dark-mode .stats .streak-counter.text-red-500 {
            color: var(--text-red-500-val) !important;
        }

        body.dark-mode .stats .timer.text-orange-500 {
            color: var(--text-orange-500-val) !important;
        }

        /* Question text color */
        body.dark-mode .question.text-gray-900 {
            /* Handles custom .question with Tailwind .text-gray-900 */
            color: var(--text-gray-900-val) !important;
        }

        #exampleSentenceDisplay {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out;
            word-break: normal;
            line-height: 1.6;
            text-align: center;
            margin-top: 0;
            color: var(--text-color-example-sentence-val);
        }

        #exampleSentenceDisplay.visible {
            max-height: 10em;
            opacity: 1;
            margin-top: 0.5rem;
        }

        /* Option selection gradient overrides for dark mode - specific to your JS logic */
        body.dark-mode .option.bg-gradient-to-br.from-indigo-500.to-purple-600 {
            background: linear-gradient(to bottom right, #60a5fa, #a78bfa);
        }

        body.dark-mode .option.bg-gradient-to-br.from-green-500.to-lime-600 {
            background: linear-gradient(to bottom right, #34d399, #86efac);
        }

        body.dark-mode .option.bg-gradient-to-br.from-red-500.to-orange-500 {
            background: linear-gradient(to bottom right, #f87171, #fb923c);
        }

        #keyboardHint {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 1rem);
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            opacity: 0;
            /* Controlled by JS */
            transition: opacity 0.3s ease;
            z-index: 50;
        }
    </style>

</head>

<body class="min-h-screen text-gray-800 relative">
    <button
        class="theme-toggle fixed top-5 right-5 bg-white bg-opacity-90 rounded-full w-12 h-12 flex items-center justify-center text-2xl cursor-pointer shadow-md transition-all duration-300 hover:scale-110 hover:shadow-lg z-50"
        onclick="toggleTheme()">ğŸŒ™</button>

    <div class="container mx-auto p-5 max-w-4xl">
        <div
            class="header bg-opacity-95 backdrop-blur-md rounded-2xl p-8 mb-8 text-center shadow-lg border border-white border-opacity-20 animate-[slideDown_0.8s_ease]">
            <!-- H1 will be set by JavaScript -->
            <h1 class="text-4xl font-bold mb-2 gradient-text">èªå½™ç·´ç¿’</h1>
            <p class="text-gray-600 text-lg">æ—¥æœ¬èªèƒ½åŠ›è©¦é¨“ã‚¹ã‚¿ã‚¤ãƒ«èªå½™ç·´ç¿’</p>
        </div>

        <div
            class="controls bg-opacity-95 backdrop-blur-md rounded-xl p-5 mb-8 flex flex-wrap gap-4 items-center justify-center shadow-lg border border-white border-opacity-20 animate-[slideUp_0.8s_ease]">
            <div class="lesson-selector flex items-center gap-2">
                <label for="lesson" class="font-semibold text-indigo-600">ãƒ¬ãƒƒã‚¹ãƒ³:</label>
                <select id="lesson"
                    class="p-2.5 rounded-lg border-2 border-indigo-300 bg-white text-base cursor-pointer transition-all duration-300 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100">
                    <option value="all">å…¨ã¦ã®ãƒ¬ãƒƒã‚¹ãƒ³</option>
                </select>
            </div>
            <div class="mode-selector flex items-center gap-2">
                <label for="mode" class="font-semibold text-indigo-600">ç·´ç¿’ãƒ¢ãƒ¼ãƒ‰:</label>
                <select id="mode"
                    class="p-2.5 rounded-lg border-2 border-indigo-300 bg-white text-base cursor-pointer transition-all duration-300 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100">
                    <option value="reading">èª­ã¿æ–¹</option>
                    <option value="meaning">æ„å‘³</option>
                    <option value="usage">ä½¿ã„æ–¹</option>
                    <option value="mixed">ãƒŸãƒƒã‚¯ã‚¹</option>
                </select>
            </div>
            <div class="difficulty-selector flex items-center gap-2">
                <label for="difficulty" class="font-semibold text-indigo-600">å•é¡Œæ•°:</label>
                <select id="difficulty"
                    class="p-2.5 rounded-lg border-2 border-indigo-300 bg-white text-base cursor-pointer transition-all duration-300 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100">
                    <option value="5">5å•</option>
                    <option value="10">10å•</option>
                    <option value="20" selected>20å•</option>
                    <option value="30">30å•</option>
                    <option value="all">å…¨ã¦</option>
                </select>
            </div>
            <div>
                <button id="startQuizButton"
                    class="btn relative overflow-hidden bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0 disabled:opacity-60 disabled:cursor-not-allowed"
                    onclick="startQuiz()" disabled>ç·´ç¿’é–‹å§‹</button>
                <button
                    class="btn secondary relative overflow-hidden bg-gradient-to-br from-red-500 to-orange-500 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0 disabled:opacity-60 disabled:cursor-not-allowed"
                    onclick="resetQuiz()">ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>

        <div class="quiz-container bg-opacity-95 backdrop-blur-md rounded-2xl p-10 shadow-lg border border-white border-opacity-20 min-h-[400px] animate-[fadeIn_0.5s_ease]"
            id="quizContainer">
            <div class="welcome-message">
                <h2 class="text-center text-2xl font-bold mb-5">ç·´ç¿’ãƒ¢ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§é–‹å§‹ã—ã¦ãã ã•ã„</h2>
                <p class="text-center text-gray-600 dark:text-gray-300 text-lg mb-8">
                    <strong>èª­ã¿æ–¹:</strong> æ¼¢å­—ã®èª­ã¿ã‚’é¸æŠ<br>
                    <strong>æ„å‘³:</strong> å˜èªã®æ„å‘³ã‚’é¸æŠ<br>
                    <strong>ä½¿ã„æ–¹:</strong> æ–‡è„ˆã«åˆã†å˜èªã‚’é¸æŠ<br>
                    <strong>ãƒŸãƒƒã‚¯ã‚¹:</strong> å…¨ç¨®é¡ã®å•é¡Œã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«<br>
                </p>
                <div
                    class="features glass-morphism mt-8 p-5 bg-indigo-100 dark:bg-indigo-900 dark:bg-opacity-40 rounded-xl">
                    <h3 class="text-center text-xl font-semibold mb-4 text-indigo-600 dark:text-indigo-400">âœ¨ æ–°æ©Ÿèƒ½</h3>
                    <ul class="text-left text-gray-600 dark:text-gray-300 leading-relaxed list-none list-inside">
                        <li>ğŸ¯ å•é¡Œæ•°é¸æŠï¼ˆ5/10/30/å…¨ã¦ï¼‰</li>
                        <li>ğŸ”¥ é€£ç¶šæ­£è§£ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</li>
                        <li>â±ï¸ å•é¡Œåˆ¥ã‚¿ã‚¤ãƒãƒ¼</li>
                        <li>ğŸŒ™ ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ</li>
                        <li>âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ</li>
                        <li>ğŸ“± å®Œå…¨ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ</li>
                        <li>ğŸ“š ãƒ¬ãƒƒã‚¹ãƒ³é¸æŠæ©Ÿèƒ½</li>
                        <li>ğŸ‡¨ğŸ‡³ æ„å‘³ç·´ç¿’ã§ä¸­å›½èªè¡¨ç¤º</li>
                        <li>âœ¨ AIã«ã‚ˆã‚‹æ–°ã—ã„ä¾‹æ–‡ç”Ÿæˆ</li>
                        <li>ğŸ“– å•é¡Œæ–‡ã‚¯ãƒªãƒƒã‚¯ã§ä¾‹æ–‡è¡¨ç¤º (å…¨ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ)</li>
                        <li>ğŸ‘† å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ã§é—®é¢˜åˆ‡æ›¿ (ãƒ¢ãƒã‚¤ãƒ«)</li>
                        <li>ğŸ–±ï¸ ã‚«ãƒ¼ãƒ‰å·¦å³ã‚¯ãƒªãƒƒã‚¯ã§å•é¡Œåˆ‡æ›¿ (ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—)</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="keyboard-shortcut fixed bottom-5 right-5 bg-gray-800 text-white py-2.5 px-4 rounded-xl text-xs opacity-0 transition-opacity duration-300 z-50"
        id="keyboardHint">
        ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰: 1-4ã§é¸æŠ, Enterã§ç¢ºå®š
    </div>

    <div id="messageBox" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="messageBoxText" class="text-lg font-semibold mb-4"></p>
            <button
                class="btn bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-2 px-4 rounded-full"
                onclick="hideMessageBox()">OK</button>
        </div>
    </div>

    <div id="generatedSentenceModal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-lg w-full text-center">
            <h3 class="text-xl font-bold mb-4 text-indigo-700">âœ¨ æ–°ã—ã„ä¾‹æ–‡</h3>
            <p id="generatedSentenceText" class="text-lg text-gray-800 mb-4"></p>
            <div id="sentenceLoadingSpinner" class="hidden">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-500 mx-auto"></div>
                <p class="text-gray-600 text-sm mt-2">ç”Ÿæˆä¸­...</p>
            </div>
            <button
                class="btn bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-2 px-4 rounded-full"
                onclick="hideGeneratedSentenceModal()">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <script>
        let allVocabulary = {};
        let currentQuiz = [];
        let currentQuestion = 0;
        let score = 0;
        let selectedAnswer = null;
        let quizMode = 'reading';
        let streak = 0;
        let maxStreak = 0;
        let startTime = null;
        let questionStartTime = null;
        let totalTime = 0;
        let wrongAnswers = [];
        let isDarkMode = false;
        let timerInterval;

        let headerElement;
        let controlsElement;
        let quizContainerElement;
        let mainContainerElement;
        let startQuizButton;
        let lessonSelectElement;
        let currentJLPTLevel = 'N2'; // Default level

        // --- æ»‘åŠ¨åŠŸèƒ½ç›¸å…³å˜é‡ ---
        let touchstartX = 0;
        let touchendX = 0;
        let touchstartY = 0;
        let touchendY = 0;
        const swipeThreshold = 50; // æ»‘åŠ¨æœ€å°åƒç´ é˜ˆå€¼

        // --- æ–°å¢: è®°å½•ç­”é¢˜å†å²å’Œæœ€è¿œè¿›åº¦çš„å˜é‡ ---
        let answerLog = []; // å­˜å‚¨æ¯é“é¢˜çš„ä½œç­”æƒ…å†µ
        let maxQuestionReachedInSession = 0; // æœ¬è½®æµ‹éªŒä¸­ç”¨æˆ·è¾¾åˆ°è¿‡çš„æœ€è¿œé¢˜ç›®ç´¢å¼• (å·²å›ç­”æˆ–æ­£åœ¨å›ç­”)


        async function loadVocabularyData(fileNameToLoad) {
            try {
                if (!startQuizButton) {
                    startQuizButton = document.getElementById('startQuizButton');
                }
                if (startQuizButton) startQuizButton.disabled = true;

                const response = await fetch(fileNameToLoad);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching ${fileNameToLoad}`);
                }
                allVocabulary = await response.json();
                console.log(`Vocabulary for ${currentJLPTLevel} loaded successfully from ${fileNameToLoad}:`, allVocabulary);
                populateLessonSelect();
                if (startQuizButton) startQuizButton.disabled = false;
            } catch (error) {
                console.error(`Could not load vocabulary from ${fileNameToLoad}:`, error);
                showMessageBox(`èªå½™ãƒ‡ãƒ¼ã‚¿(${fileNameToLoad})ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ã€å†…å®¹ãŒæ­£ã—ã„JSONå½¢å¼ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
                if (startQuizButton) startQuizButton.disabled = true;
            }
        }

        function initializeApp() {
            const urlParams = new URLSearchParams(window.location.search);
            const levelParam = urlParams.get('level');
            const allowedLevels = ['n1', 'n2', 'n3'];

            let determinedLevel = 'n2';

            if (levelParam && allowedLevels.includes(levelParam.toLowerCase())) {
                determinedLevel = levelParam.toLowerCase();
            } else if (levelParam) {
                console.warn(`Invalid level parameter '${levelParam}' provided. Defaulting to N2.`);
            }

            currentJLPTLevel = determinedLevel.toUpperCase();
            const jsonFileName = `${determinedLevel}.json`;

            document.title = `æ–°ç„¡æ•µç·‘å®æ›¸${currentJLPTLevel}å˜èªç·´ç¿’`;
            const h1Element = document.querySelector('.header h1.gradient-text');
            if (h1Element) {
                h1Element.textContent = `æ–°ç„¡æ•µç·‘å®æ›¸${currentJLPTLevel}èªå½™ç·´ç¿’`;
            }

            loadVocabularyData(jsonFileName);
        }

        function populateLessonSelect() {
            if (!lessonSelectElement) return;
            lessonSelectElement.innerHTML = '<option value="all">å…¨ã¦ã®ãƒ¬ãƒƒã‚¹ãƒ³</option>';

            const lessonKeys = Object.keys(allVocabulary);
            lessonKeys.sort((a, b) => {
                const numA = parseInt(a.replace('lesson', ''), 10);
                const numB = parseInt(b.replace('lesson', ''), 10);
                return numA - numB;
            });

            lessonKeys.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key.replace('lesson', 'ãƒ¬ãƒƒã‚¹ãƒ³');
                lessonSelectElement.appendChild(option);
            });
        }


        document.addEventListener('DOMContentLoaded', () => {
            headerElement = document.querySelector('.header');
            controlsElement = document.querySelector('.controls');
            quizContainerElement = document.getElementById('quizContainer');
            mainContainerElement = document.querySelector('.container');
            startQuizButton = document.getElementById('startQuizButton');
            lessonSelectElement = document.getElementById('lesson');

            initializeApp();

            const difficultySelect = document.getElementById('difficulty');
            if (difficultySelect) {
                difficultySelect.value = "20";
            }
        });

        function showMessageBox(message) {
            document.getElementById('messageBoxText').textContent = message;
            document.getElementById('messageBox').classList.remove('hidden');
        }

        function hideMessageBox() {
            document.getElementById('messageBox').classList.add('hidden');
        }

        function showGeneratedSentenceModal(sentence) {
            document.getElementById('generatedSentenceText').textContent = sentence;
            document.getElementById('sentenceLoadingSpinner').classList.add('hidden');
            document.getElementById('generatedSentenceModal').classList.remove('hidden');
        }

        function hideGeneratedSentenceModal() {
            document.getElementById('generatedSentenceModal').classList.add('hidden');
            document.getElementById('generatedSentenceText').textContent = '';
        }

        function showSentenceLoadingSpinner() {
            document.getElementById('generatedSentenceText').textContent = '';
            document.getElementById('sentenceLoadingSpinner').classList.remove('hidden');
            document.getElementById('generatedSentenceModal').classList.remove('hidden');
        }

        document.addEventListener('keydown', (e) => {
            if (!document.getElementById('messageBox').classList.contains('hidden') ||
                !document.getElementById('generatedSentenceModal').classList.contains('hidden')) {
                return;
            }

            const optionsElements = document.querySelectorAll('.option');
            const isViewingPastAnswer = optionsElements.length > 0 && optionsElements[0].disabled;

            if (isViewingPastAnswer && e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') {
                return;
            }
            if (selectedAnswer !== null && !isViewingPastAnswer) {
                if (e.key === 'Enter') submitAnswer();
                return;
            }
            if (isViewingPastAnswer && (e.key === 'Enter' || (e.key >= '1' && e.key <= '4'))) {
                return;
            }

            const key = e.key;
            if (key >= '1' && key <= '4' && !isViewingPastAnswer) {
                const index = parseInt(key) - 1;
                if (optionsElements[index] && !optionsElements[index].disabled) {
                    selectAnswer(index);
                }
            } else if (key === 'Enter' && selectedAnswer !== null && !isViewingPastAnswer) {
                submitAnswer();
            } else if (key === 'ArrowLeft') {
                navigateToPreviousQuestion();
            } else if (key === 'ArrowRight') {
                navigateToNextQuestion();
            }
        });


        function showKeyboardHint() {
            const hint = document.getElementById('keyboardHint');
            hint.classList.add('opacity-100');
            setTimeout(() => {
                hint.classList.remove('opacity-100');
            }, 3000);
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function isReadingSameAsWord(vocab) {
            return vocab.w === vocab.r;
        }

        function generateQuestion(vocab, mode, allAvailableVocab) {
            const correctAnswer = vocab;
            let otherVocab = allAvailableVocab.filter(v => v.w !== vocab.w);
            if (otherVocab.length < 3) {
                const needed = 3 - otherVocab.length;
                for (let i = 0; i < needed; i++) {
                    let randomVocab;
                    do {
                        randomVocab = allAvailableVocab[Math.floor(Math.random() * allAvailableVocab.length)];
                    } while (randomVocab.w === vocab.w || otherVocab.some(ov => ov.w === randomVocab.w));
                    if (randomVocab) otherVocab.push(randomVocab);
                }
                otherVocab = otherVocab.filter(v => v.w !== vocab.w).slice(0, 3);
            }

            const wrongAnswersPool = shuffleArray(otherVocab).slice(0, 3);
            while (wrongAnswersPool.length < 3) {
                let randomFallback = allAvailableVocab[Math.floor(Math.random() * allAvailableVocab.length)];
                if (randomFallback.w !== vocab.w && !wrongAnswersPool.some(w => w.w === randomFallback.w)) {
                    wrongAnswersPool.push(randomFallback);
                } else if (randomFallback.w !== vocab.w) {
                    wrongAnswersPool.push(randomFallback);
                } else if (allAvailableVocab.length > 1) {
                    let anotherFallback;
                    do {
                        anotherFallback = allAvailableVocab[Math.floor(Math.random() * allAvailableVocab.length)];
                    } while (anotherFallback.w === vocab.w && allAvailableVocab.length > 1);
                    wrongAnswersPool.push(anotherFallback);
                } else {
                    wrongAnswersPool.push({ w: "---", r: "---", m: "---", c: "---" });
                }
            }


            if (mode === 'reading') {
                if (isReadingSameAsWord(vocab)) {
                    console.warn(`Skipping reading question for word where reading is same as word: ${vocab.w}. Falling back to meaning.`);
                    const meaningQuestion = generateQuestion(vocab, 'meaning', allAvailableVocab);
                    if (meaningQuestion) {
                        meaningQuestion.originalIntendedMode = 'reading';
                    }
                    return meaningQuestion;
                }
                return {
                    question: vocab.w,
                    options: shuffleArray([
                        { text: correctAnswer.r, correct: true },
                        { text: wrongAnswersPool[0] ? wrongAnswersPool[0].r : '---', correct: false },
                        { text: wrongAnswersPool[1] ? wrongAnswersPool[1].r : '---', correct: false },
                        { text: wrongAnswersPool[2] ? wrongAnswersPool[2].r : '---', correct: false }
                    ]),
                    correctAnswer: correctAnswer.r,
                    vocab: vocab,
                    mode: 'reading'
                };
            } else if (mode === 'meaning') {
                const correctMeaning = correctAnswer.c || correctAnswer.m;
                const wrongMeaning1 = wrongAnswersPool[0] ? (wrongAnswersPool[0].c || wrongAnswersPool[0].m) : '---';
                const wrongMeaning2 = wrongAnswersPool[1] ? (wrongAnswersPool[1].c || wrongAnswersPool[1].m) : '---';
                const wrongMeaning3 = wrongAnswersPool[2] ? (wrongAnswersPool[2].c || wrongAnswersPool[2].m) : '---';
                return {
                    question: vocab.w + (vocab.w !== vocab.r ? ' (' + vocab.r + ')' : ''),
                    options: shuffleArray([
                        { text: correctMeaning, correct: true },
                        { text: wrongMeaning1, correct: false },
                        { text: wrongMeaning2, correct: false },
                        { text: wrongMeaning3, correct: false }
                    ]),
                    correctAnswer: correctMeaning,
                    vocab: vocab,
                    mode: 'meaning'
                };
            } else { // usage mode
                if (!vocab.u) {
                    console.warn(`Skipping usage question for word: ${vocab.w} (no usage provided). Falling back to meaning.`);
                    return generateQuestion(vocab, 'meaning', allAvailableVocab);
                }
                return {
                    question: vocab.u,
                    options: shuffleArray([
                        { text: correctAnswer.w, correct: true },
                        { text: wrongAnswersPool[0] ? wrongAnswersPool[0].w : '---', correct: false },
                        { text: wrongAnswersPool[1] ? wrongAnswersPool[1].w : '---', correct: false },
                        { text: wrongAnswersPool[2] ? wrongAnswersPool[2].w : '---', correct: false }
                    ]),
                    correctAnswer: correctAnswer.w,
                    vocab: vocab,
                    mode: 'usage'
                };
            }
        }


        function startQuiz() {
            if (Object.keys(allVocabulary).length === 0) {
                showMessageBox(`èªå½™ãƒ‡ãƒ¼ã‚¿(${currentJLPTLevel})ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å°‘ã€…ãŠå¾…ã¡ã„ãŸã ãã‹ã€ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚`);
                return;
            }

            if (headerElement) headerElement.classList.add('hidden-during-quiz');
            if (controlsElement) controlsElement.classList.add('hidden-during-quiz');
            document.body.classList.add('quiz-mode-active');
            if (quizContainerElement) quizContainerElement.classList.add('immersive-active');

            const selectedLesson = document.getElementById('lesson').value;
            quizMode = document.getElementById('mode').value;
            const difficulty = document.getElementById('difficulty').value;

            let sourceVocab = [];
            if (selectedLesson === 'all') {
                for (const lessonKey in allVocabulary) {
                    if (allVocabulary.hasOwnProperty(lessonKey) && Array.isArray(allVocabulary[lessonKey])) {
                        sourceVocab = sourceVocab.concat(allVocabulary[lessonKey]);
                    }
                }
            } else {
                if (allVocabulary.hasOwnProperty(selectedLesson) && Array.isArray(allVocabulary[selectedLesson])) {
                    sourceVocab = allVocabulary[selectedLesson];
                } else {
                    showMessageBox(`ãƒ¬ãƒƒã‚¹ãƒ³ "${selectedLesson}" ã®å˜èªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ (${currentJLPTLevel} ãƒ‡ãƒ¼ã‚¿)ã€‚`);
                    resetQuizInterface();
                    return;
                }
            }

            if (sourceVocab.length === 0) {
                showMessageBox(`é¸æŠã•ã‚ŒãŸãƒ¬ãƒƒã‚¹ãƒ³ã«ã¯å˜èªãŒã‚ã‚Šã¾ã›ã‚“ (${currentJLPTLevel} ãƒ‡ãƒ¼ã‚¿)ã€‚`);
                resetQuizInterface();
                return;
            }
            sourceVocab = sourceVocab.filter(item => typeof item === 'object' && item !== null && item.w);


            let questionCount;
            if (difficulty === 'all') {
                questionCount = sourceVocab.length;
            } else {
                questionCount = parseInt(difficulty);
            }

            if (sourceVocab.length < questionCount && difficulty !== 'all') {
                showMessageBox(`é¸æŠã•ã‚ŒãŸãƒ¬ãƒƒã‚¹ãƒ³ã«ã¯ ${sourceVocab.length} å€‹ã®å˜èªã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚å•é¡Œæ•°ã‚’èª¿æ•´ã—ã¾ã—ãŸã€‚`);
                questionCount = sourceVocab.length;
            }
            if (questionCount === 0 && sourceVocab.length > 0) {
                questionCount = Math.min(10, sourceVocab.length);
            }
            if (questionCount === 0) {
                showMessageBox('å•é¡Œæ•°ãŒ0ã§ã™ã€‚å•é¡Œæ•°ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                resetQuizInterface();
                return;
            }


            const shuffledVocabForQuiz = shuffleArray(sourceVocab).slice(0, questionCount);

            let generatedQuestions = [];
            const modes = ['reading', 'meaning', 'usage'];

            for (const vocab of shuffledVocabForQuiz) {
                let question = null;
                if (quizMode === 'mixed') {
                    const shuffledModes = shuffleArray([...modes]);
                    for (const mode of shuffledModes) {
                        question = generateQuestion(vocab, mode, sourceVocab);
                        if (question) break;
                    }
                } else {
                    question = generateQuestion(vocab, quizMode, sourceVocab);
                }
                if (question) {
                    generatedQuestions.push(question);
                } else {
                    console.warn(`Could not generate a valid question for vocab: ${vocab.w} in mode: ${quizMode}`);
                }
            }

            currentQuiz = generatedQuestions;


            if (currentQuiz.length === 0) {
                showMessageBox('é¸æŠã•ã‚ŒãŸæ¡ä»¶ã§å•é¡Œã‚’ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚åˆ¥ã®ãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ãƒ¬ãƒƒã‚¹ãƒ³ã‚’è©¦ã—ã¦ãã ã•ã„ã€‚');
                resetQuiz();
                return;
            }

            currentQuestion = 0;
            score = 0;
            streak = 0;
            maxStreak = 0;
            wrongAnswers = [];
            selectedAnswer = null;
            startTime = Date.now();
            totalTime = 0;

            answerLog = [];
            maxQuestionReachedInSession = 0;

            touchstartX = 0;
            touchendX = 0;
            touchstartY = 0;
            touchendY = 0;
            if (quizContainerElement) {
                quizContainerElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                quizContainerElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                quizContainerElement.addEventListener('touchend', handleTouchEnd, { passive: false });
                quizContainerElement.addEventListener('click', handleCardClick); // Added
            }

            showKeyboardHint();
            showQuestion();
        }

        function showQuestion() {
            if (currentQuestion >= currentQuiz.length) {
                showFinalScore();
                return;
            }

            const question = currentQuiz[currentQuestion];
            const container = quizContainerElement;

            const historyEntry = answerLog.find(log => log.questionIndex === currentQuestion);

            if (!historyEntry) {
                questionStartTime = Date.now();
            }


            let questionTextHTML = `<div class="question text-2xl md:text-3xl mb-1 md:mb-2 font-semibold text-center text-gray-900 leading-tight" id="questionText">${question.question}</div>`;
            let exampleSentenceHTML = `<div id="exampleSentenceDisplay" class="text-gray-700 text-mi px-2"></div>`;

            container.innerHTML = `
            <button class="exit-btn" onclick="resetQuiz()">âœ•</button>
            <div class="progress-container mb-4 md:mb-8">
                <div class="progress-info flex justify-between mb-2 font-semibold text-indigo-600">
                    <span>${currentQuestion + 1} / ${currentQuiz.length}</span>
                </div>
                <div class="progress-bar w-full h-2.5 bg-indigo-200 rounded-md overflow-hidden relative">
                    <div class="progress-fill h-full bg-gradient-to-r from-indigo-500 to-purple-600 rounded-md transition-all duration-500 ease-in-out relative" style="width: ${(currentQuestion / currentQuiz.length) * 100}%"></div>
                </div>
            </div>
            <div class="stats flex justify-between mb-3 md:mb-5 text-sm md:text-lg font-semibold flex-wrap gap-2">
                <span class="score text-green-600 flex items-center gap-1 md:gap-2">âœ… æ­£è§£: ${score}</span>
                <span class="streak-counter text-red-500 flex items-center gap-1 md:gap-2">ğŸ”¥ é€£ç¶š: ${streak}</span>
                <span class="timer text-orange-500 flex items-center gap-1 md:gap-2">â±ï¸ çµŒé: <span id="timer">${historyEntry ? historyEntry.timeSpent : 0}</span>s</span>
            </div>
            
            <div class="question-area-wrapper">
                <div class="question-content-area">
                    ${questionTextHTML}
                    ${exampleSentenceHTML}
                </div>
            </div>

            <div class="options grid grid-cols-1 md:grid-cols-2 gap-2.5 sm:gap-3 md:gap-4">
                ${question.options.map((option, index) => `
                    <button class="option relative overflow-hidden border-2 p-3 md:p-5 rounded-xl cursor-pointer transition-all duration-300 text-base md:text-lg text-center" onclick="selectAnswer(${index})" data-index="${index}">
                        <span class="font-bold mr-2 ${isDarkMode ? 'text-indigo-300' : 'text-indigo-500'}">${index + 1}.</span>
                        ${option.text}
                    </button>
                `).join('')}
            </div>
            <div class="feedback text-center text-lg md:text-xl font-semibold"></div>
        `;

            const feedbackElement = container.querySelector('.feedback');
            const optionElements = container.querySelectorAll('.option');

            if (historyEntry) {
                clearInterval(timerInterval);
                feedbackElement.className = `feedback text-center text-lg md:text-xl font-semibold p-3 md:p-4 rounded-lg ${historyEntry.isCorrect ? 'text-green-600 bg-green-50 border-2 border-green-200' : 'text-red-600 bg-red-50 border-2 border-red-200'}`;
                if (isDarkMode) {
                    if (historyEntry.isCorrect) feedbackElement.classList.add('dark:bg-green-900', 'dark:bg-opacity-30', 'dark:border-green-700');
                    else feedbackElement.classList.add('dark:bg-red-900', 'dark:bg-opacity-30', 'dark:border-red-700');
                }

                let feedbackText = historyEntry.isCorrect ? `ğŸ‰ æ­£è§£ï¼ (${historyEntry.timeSpent}ç§’)` : `âŒ ä¸æ­£è§£ã€‚æ­£è§£ã¯â€œ${question.correctAnswer}â€ã€‚`;
                if (!historyEntry.isCorrect && question.vocab) {
                    const displayMeaning = question.vocab.c || question.vocab.m;
                    feedbackText += `<br><small class="text-gray-600 dark:text-slate-400 opacity-90 dark:opacity-85 text-sm md:text-base">
                    ${question.vocab.w} ${question.vocab.w !== question.vocab.r ? '(' + question.vocab.r + ')' : ''} - ${displayMeaning}
                </small>`;
                }
                feedbackElement.innerHTML = feedbackText;
                feedbackElement.style.visibility = 'visible';

                optionElements.forEach((opt, i) => {
                    opt.disabled = true;
                    opt.classList.remove('selected-option', 'bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white', 'border-indigo-500', 'from-green-500', 'to-lime-600', 'border-green-500', 'from-red-500', 'to-orange-500', 'border-red-500', 'animate-[incorrectShake_0.3s_ease]');
                    opt.style.borderColor = '';

                    if (question.options[i].correct) {
                        opt.classList.add('bg-gradient-to-br', 'from-green-500', 'to-lime-600', 'text-white', 'border-green-500');
                    }
                    if (i === historyEntry.selectedOptionIndex && !historyEntry.isCorrect) {
                        opt.classList.add('bg-gradient-to-br', 'from-red-500', 'to-orange-500', 'text-white', 'border-red-500');
                    }
                });

            } else {
                if (feedbackElement) {
                    feedbackElement.style.visibility = 'hidden';
                    feedbackElement.innerHTML = '';
                }
                optionElements.forEach(opt => {
                    opt.disabled = false;
                    opt.classList.remove('selected-option', 'bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white', 'border-indigo-500', 'from-green-500', 'to-lime-600', 'border-green-500', 'from-red-500', 'to-orange-500', 'border-red-500', 'animate-[incorrectShake_0.3s_ease]');
                    opt.style.borderColor = '';
                });
                updateTimer();
            }


            const questionTextElement = document.getElementById('questionText');
            const exampleSentenceDisplayElement = document.getElementById('exampleSentenceDisplay');

            if (exampleSentenceDisplayElement) {
                exampleSentenceDisplayElement.classList.remove('visible');
                exampleSentenceDisplayElement.textContent = '';
            }

            const canShowExampleOnClick = question.vocab && question.vocab.e;

            if (questionTextElement && exampleSentenceDisplayElement && canShowExampleOnClick) {
                questionTextElement.style.cursor = 'pointer';
                questionTextElement.title = 'ã‚¯ãƒªãƒƒã‚¯ã—ã¦ä¾‹æ–‡ã‚’è¡¨ç¤º/éè¡¨ç¤º';

                questionTextElement.onclick = () => {
                    const isViewingPast = optionElements.length > 0 && optionElements[0].disabled;
                    if (selectedAnswer !== null && !isViewingPast) return;

                    if (!exampleSentenceDisplayElement.classList.contains('visible')) {
                        exampleSentenceDisplayElement.textContent = question.vocab.e;
                        exampleSentenceDisplayElement.classList.add('visible');
                    } else {
                        exampleSentenceDisplayElement.classList.remove('visible');
                    }
                };
            }
        }

        function updateTimer() {
            clearInterval(timerInterval);
            const isViewingPastAnswer = currentQuestion < maxQuestionReachedInSession && answerLog.find(log => log.questionIndex === currentQuestion);

            if (currentQuestion >= currentQuiz.length || selectedAnswer !== null || isViewingPastAnswer) {
                return;
            }

            const timerElement = document.getElementById('timer');
            if (timerElement && questionStartTime) {
                const update = () => {
                    const isStillViewingPastAnswer = currentQuestion < maxQuestionReachedInSession && answerLog.find(log => log.questionIndex === currentQuestion);
                    if (selectedAnswer !== null || currentQuestion >= currentQuiz.length || isStillViewingPastAnswer) {
                        clearInterval(timerInterval);
                        return;
                    }
                    const elapsed = Math.floor((Date.now() - questionStartTime) / 1000);
                    timerElement.textContent = elapsed;
                };
                update();
                timerInterval = setInterval(update, 1000);
            }
        }

        function selectAnswer(index) {
            const optionButton = document.querySelectorAll('.option')[index];
            if (selectedAnswer !== null || (optionButton && optionButton.disabled)) {
                return;
            }
            selectedAnswer = index;
            clearInterval(timerInterval);

            const exampleSentenceDisplayElement = document.getElementById('exampleSentenceDisplay');
            if (exampleSentenceDisplayElement) {
                exampleSentenceDisplayElement.classList.remove('visible');
            }

            document.querySelectorAll('.option').forEach((optionEl, i) => {
                optionEl.classList.remove('selected-option');
                optionEl.classList.remove('bg-gradient-to-br', 'from-indigo-500', 'to-purple-600', 'text-white', 'border-indigo-500');
                optionEl.style.borderColor = '';

                if (i === index) {
                    optionEl.classList.add('selected-option');
                    optionEl.classList.add('bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white');
                    optionEl.style.borderColor = isDarkMode ? '#a78bfa' : '#818cf8';
                }
            });
            setTimeout(() => { submitAnswer(); }, 100);
        }

        function submitAnswer() {
            if (selectedAnswer === null) return;

            const optionButton = document.querySelectorAll('.option')[selectedAnswer];
            if (optionButton && optionButton.disabled) {
                selectedAnswer = null;
                return;
            }

            document.querySelectorAll('.option').forEach(optionEl => {
                optionEl.classList.remove('selected-option');
                optionEl.classList.remove('bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white');
                optionEl.style.borderColor = '';
            });

            const question = currentQuiz[currentQuestion];
            const isCorrect = question.options[selectedAnswer].correct;
            const timeSpent = Math.floor((Date.now() - questionStartTime) / 1000);
            totalTime += timeSpent;

            answerLog.push({
                questionIndex: currentQuestion,
                selectedOptionIndex: selectedAnswer,
                isCorrect: isCorrect,
                timeSpent: timeSpent,
            });

            if (isCorrect) {
                score++;
                streak++;
                if (streak > maxStreak) maxStreak = streak;
            } else {
                streak = 0;
                wrongAnswers.push({
                    question: question.question,
                    yourAnswer: question.options[selectedAnswer].text,
                    correctAnswer: question.correctAnswer,
                    questionNumber: currentQuestion + 1,
                    vocab: question.vocab,
                    timeSpent: timeSpent,
                    mode: question.mode
                });
            }

            document.querySelectorAll('.option').forEach((option, i) => {
                option.disabled = true;
                if (question.options[i].correct) {
                    option.classList.add('bg-gradient-to-br', 'from-green-500', 'to-lime-600', 'text-white', 'border-green-500');
                } else if (i === selectedAnswer && !isCorrect) {
                    option.classList.add('bg-gradient-to-br', 'from-red-500', 'to-orange-500', 'text-white', 'border-red-500', 'animate-[incorrectShake_0.3s_ease]');
                }
            });

            const feedbackElement = document.querySelector('.feedback');
            feedbackElement.className = `feedback text-center text-lg md:text-xl font-semibold p-3 md:p-4 rounded-lg ${isCorrect ? 'text-green-600 bg-green-50 border-2 border-green-200' : 'text-red-600 bg-red-50 border-2 border-red-200'}`;
            if (isDarkMode) {
                if (isCorrect) feedbackElement.classList.add('dark:bg-green-900', 'dark:bg-opacity-30', 'dark:border-green-700');
                else feedbackElement.classList.add('dark:bg-red-900', 'dark:bg-opacity-30', 'dark:border-red-700');
            }

            let feedbackText = isCorrect ? `ğŸ‰ æ­£è§£ï¼ (${timeSpent}ç§’)` : `âŒ ä¸æ­£è§£ã€‚æ­£è§£ã¯â€œ${question.correctAnswer}â€ã€‚`;
            if (!isCorrect && question.vocab) {
                const displayMeaning = question.vocab.c || question.vocab.m;
                feedbackText += `<br><small class="text-gray-600 dark:text-slate-400 opacity-90 dark:opacity-85 text-sm md:text-base">
                ${question.vocab.w} ${question.vocab.w !== question.vocab.r ? '(' + question.vocab.r + ')' : ''} - ${displayMeaning}
            </small>`;
            }
            feedbackElement.innerHTML = feedbackText;

            if (feedbackElement) {
                feedbackElement.style.visibility = 'visible';
            }

            const delay = isCorrect ? 500 : 1200;
            setTimeout(() => {
                nextQuestion();
            }, delay);
        }

        function nextQuestion() {
            currentQuestion++;
            selectedAnswer = null;

            if (currentQuestion > maxQuestionReachedInSession) {
                maxQuestionReachedInSession = currentQuestion;
            }
            showQuestion();
        }

        function resetQuizInterface() {
            if (headerElement) headerElement.classList.remove('hidden-during-quiz');
            if (controlsElement) controlsElement.classList.remove('hidden-during-quiz');
            document.body.classList.remove('quiz-mode-active');
            if (quizContainerElement) {
                quizContainerElement.classList.remove('immersive-active');
                quizContainerElement.style.paddingTop = '';
                quizContainerElement.style.paddingBottom = '';
                quizContainerElement.style.paddingLeft = '';
                quizContainerElement.style.paddingRight = '';

                quizContainerElement.removeEventListener('touchstart', handleTouchStart);
                quizContainerElement.removeEventListener('touchmove', handleTouchMove);
                quizContainerElement.removeEventListener('touchend', handleTouchEnd);
                quizContainerElement.removeEventListener('click', handleCardClick); // Added
            }
        }

        function showFinalScore() {
            resetQuizInterface();
            clearInterval(timerInterval);
            totalTime = Math.floor((Date.now() - startTime) / 1000);
            const percentage = currentQuiz.length > 0 ? Math.round((score / currentQuiz.length) * 100) : 0;
            const avgTime = currentQuiz.length > 0 ? Math.round(totalTime / currentQuiz.length) : 0;

            let message = '';
            let emoji = '';
            if (percentage >= 90) {
                message = 'ç´ æ™´ã‚‰ã—ã„ï¼';
                emoji = 'ğŸ†';
            } else if (percentage >= 70) {
                message = 'ã‚ˆãã§ãã¾ã—ãŸï¼';
                emoji = 'ğŸ‰';
            } else if (percentage >= 50) {
                message = 'ã‚‚ã†å°‘ã—é ‘å¼µã‚Šã¾ã—ã‚‡ã†ã€‚';
                emoji = 'ğŸ’ª';
            } else {
                message = 'å¾©ç¿’ãŒå¿…è¦ã§ã™ã€‚';
                emoji = 'ğŸ“š';
            }

            let wrongAnswersHtml = '';
            if (wrongAnswers.length > 0) {
                wrongAnswersHtml = `
                <div class="wrong-answers-section mt-8 text-left animate-[slideUp_0.8s_ease]">
                    <h3 class="text-center text-2xl font-bold mb-5 text-red-600">${emoji} å¾©ç¿’ãŒå¿…è¦ãªå˜èª (${wrongAnswers.length}å€‹)</h3>
                    <div class="wrong-answers-list max-h-80 overflow-y-auto bg-red-50 dark:bg-red-900 dark:bg-opacity-30 rounded-lg p-5 border border-red-200 dark:border-red-700">
                        ${wrongAnswers.map(wrong => `
                            <div class="wrong-answer-item mb-4 p-4 bg-white dark:bg-gray-700 rounded-lg border-l-4 border-red-500 shadow-md transition-transform duration-200 hover:translate-x-1">
                                <div class="font-bold mb-2 text-gray-900 dark:text-gray-100 text-lg">å•é¡Œ${wrong.questionNumber}: ${wrong.question}</div>
                                <div class="text-red-600 dark:text-red-400 mb-1 flex items-center gap-2">âŒ ã‚ãªãŸã®å›ç­”: ${wrong.yourAnswer} <span class="bg-red-500 text-white py-0.5 px-2 rounded-full text-xs">${wrong.timeSpent}ç§’</span></div>
                                <div class="text-green-600 dark:text-green-400 mb-2">âœ… æ­£è§£: ${wrong.correctAnswer}</div>
                                ${wrong.vocab ? `<div class="bg-indigo-100 dark:bg-indigo-900 dark:bg-opacity-40 p-2 rounded-md text-sm text-gray-700 dark:text-gray-300">
                                    <strong>${wrong.vocab.w}</strong> ${wrong.vocab.w !== wrong.vocab.r ? '(' + wrong.vocab.r + ')' : ''}<br>
                                    æ„å‘³: ${wrong.vocab.c || wrong.vocab.m}<br>
                                    å…ƒã€…ã®ä¾‹æ–‡: ${wrong.vocab.u || 'ãªã—'}<br>
                                    ${wrong.vocab.e ? `åéŒ²ä¾‹æ–‡: ${wrong.vocab.e}<br>` : ''}
                                    <button class="generate-sentence-btn mt-2 px-3 py-1.5 bg-blue-500 text-white text-sm rounded-full hover:bg-blue-600 transition-colors duration-200" onclick="generateExampleSentence(this, '${wrong.vocab.w.replace(/'/g, "\\'")}', '${wrong.vocab.r.replace(/'/g, "\\'")}', '${(wrong.vocab.c || wrong.vocab.m).replace(/'/g, "\\'")}')">âœ¨ æ–°ã—ã„ä¾‹æ–‡ã‚’ç”Ÿæˆ</button>
                                </div>` : ''}
                            </div>`).join('')}
                    </div>
                </div>`;
            }

            quizContainerElement.innerHTML = `
            <div class="final-score text-center text-gray-900 dark:text-gray-100 text-3xl font-bold my-8 animate-[fadeIn_1s_ease]">
                <h2 class="text-4xl">${emoji} ${message}</h2>
                <div class="text-indigo-600 dark:text-indigo-400 my-5 text-2xl">${score} / ${currentQuiz.length} æ­£è§£</div>
                <div class="text-gray-600 dark:text-gray-400 text-xl mb-5">æ­£ç­”ç‡: ${percentage}%</div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 my-8 text-base">
                    <div class="bg-green-50 dark:bg-green-900 dark:bg-opacity-30 p-4 rounded-lg text-center"><div class="text-green-600 dark:text-green-400 font-bold">ğŸ”¥ æœ€é«˜é€£ç¶šæ­£è§£</div><div class="text-2xl font-bold">${maxStreak}</div></div>
                    <div class="bg-orange-50 dark:bg-orange-900 dark:bg-opacity-30 p-4 rounded-lg text-center"><div class="text-orange-600 dark:text-orange-400 font-bold">â±ï¸ ç·æ™‚é–“</div><div class="text-2xl font-bold">${Math.floor(totalTime / 60)}:${(totalTime % 60).toString().padStart(2, '0')}</div></div>
                    <div class="bg-indigo-50 dark:bg-indigo-900 dark:bg-opacity-30 p-4 rounded-lg text-center"><div class="text-indigo-600 dark:text-indigo-400 font-bold">ğŸ“Š å¹³å‡æ™‚é–“</div><div class="text-2xl font-bold">${avgTime}ç§’</div></div>
                </div>
                ${wrongAnswersHtml}
                <div class="flex gap-4 justify-center mt-8 flex-wrap">
                    <button class="btn relative overflow-hidden bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0" onclick="startQuiz()">ã‚‚ã†ä¸€åº¦</button>
                    <button class="btn secondary relative overflow-hidden bg-gradient-to-br from-red-500 to-orange-500 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0 ${wrongAnswers.length === 0 ? 'opacity-50 cursor-not-allowed' : ''}" onclick="reviewWrongAnswers()" ${wrongAnswers.length === 0 ? 'disabled' : ''}>å¾©ç¿’ãƒ¢ãƒ¼ãƒ‰</button>
                </div>
            </div>`;
        }

        function reviewWrongAnswers() {
            if (wrongAnswers.length === 0) {
                showMessageBox('å¾©ç¿’ã™ã‚‹å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ï¼');
                return;
            }

            if (headerElement) headerElement.classList.add('hidden-during-quiz');
            if (controlsElement) controlsElement.classList.add('hidden-during-quiz');
            document.body.classList.add('quiz-mode-active');
            if (quizContainerElement) quizContainerElement.classList.add('immersive-active');

            let allCombinedVocab = [];
            for (const lessonKey in allVocabulary) {
                if (allVocabulary.hasOwnProperty(lessonKey) && Array.isArray(allVocabulary[lessonKey])) {
                    allCombinedVocab = allCombinedVocab.concat(allVocabulary[lessonKey]);
                }
            }
            if (allCombinedVocab.length === 0) {
                allCombinedVocab = wrongAnswers.map(w => w.vocab).filter(Boolean);
            }
            allCombinedVocab = allCombinedVocab.filter(item => typeof item === 'object' && item !== null && item.w);


            currentQuiz = wrongAnswers.map(wrong => {
                const vocab = wrong.vocab;
                if (!vocab || typeof vocab.w === 'undefined') {
                    console.error("Invalid vocab item in wrongAnswers:", wrong);
                    return null;
                }
                const modes = ['reading', 'meaning', 'usage'];
                const reviewMode = wrong.mode && modes.includes(wrong.mode) ? wrong.mode : modes[Math.floor(Math.random() * modes.length)];
                const vocabSourceForOptions = allCombinedVocab.length > 0 ? allCombinedVocab : [vocab];
                return generateQuestion(vocab, reviewMode, vocabSourceForOptions);
            }).filter(Boolean);


            if (currentQuiz.length === 0) {
                showMessageBox('å¾©ç¿’å•é¡Œã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                resetQuiz();
                return;
            }

            currentQuestion = 0;
            score = 0;
            streak = 0;
            maxStreak = 0;
            selectedAnswer = null;
            startTime = Date.now();
            totalTime = 0;
            wrongAnswers = [];

            answerLog = [];
            maxQuestionReachedInSession = 0;

            touchstartX = 0;
            touchendX = 0;
            touchstartY = 0;
            touchendY = 0;
            if (quizContainerElement) {
                quizContainerElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                quizContainerElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                quizContainerElement.addEventListener('touchend', handleTouchEnd, { passive: false });
                quizContainerElement.addEventListener('click', handleCardClick); // Added
            }
            showQuestion();
        }

        function resetQuiz() {
            resetQuizInterface();
            clearInterval(timerInterval);
            quizContainerElement.innerHTML = `
            <div class="welcome-message">
                <h2 class="text-center text-2xl font-bold mb-5">ç·´ç¿’ãƒ¢ãƒ¼ãƒ‰ã‚’é¸ã‚“ã§é–‹å§‹ã—ã¦ãã ã•ã„</h2>
                <p class="text-center text-gray-600 dark:text-gray-300 text-lg mb-8">
                    <strong>èª­ã¿æ–¹:</strong> æ¼¢å­—ã®èª­ã¿ã‚’é¸æŠ<br>
                    <strong>æ„å‘³:</strong> å˜èªã®æ„å‘³ã‚’é¸æŠ<br>
                    <strong>ä½¿ã„æ–¹:</strong> æ–‡è„ˆã«åˆã†å˜èªã‚’é¸æŠ<br>
                    <strong>ãƒŸãƒƒã‚¯ã‚¹:</strong> å…¨ç¨®é¡ã®å•é¡Œã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«<br>
                </p>
                <div class="features glass-morphism mt-8 p-5 bg-indigo-100 dark:bg-indigo-900 dark:bg-opacity-40 rounded-xl">
                    <h3 class="text-center text-xl font-semibold mb-4 text-indigo-600 dark:text-indigo-400">âœ¨ æ–°æ©Ÿèƒ½</h3>
                    <ul class="text-left text-gray-600 dark:text-gray-300 leading-relaxed list-none list-inside">
                        <li>ğŸ¯ å•é¡Œæ•°é¸æŠï¼ˆ5/10/30/å…¨ã¦ï¼‰</li>
                        <li>ğŸ”¥ é€£ç¶šæ­£è§£ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</li>
                        <li>â±ï¸ å•é¡Œåˆ¥ã‚¿ã‚¤ãƒãƒ¼</li>
                        <li>ğŸŒ™ ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ</li>
                        <li>âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ</li>
                        <li>ğŸ“± å®Œå…¨ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ</li>
                        <li>ğŸ“š ãƒ¬ãƒƒã‚¹ãƒ³é¸æŠæ©Ÿèƒ½</li>
                        <li>ğŸ‡¨ğŸ‡³ æ„å‘³ç·´ç¿’ã§ä¸­å›½èªè¡¨ç¤º</li>
                        <li>âœ¨ AIã«ã‚ˆã‚‹æ–°ã—ã„ä¾‹æ–‡ç”Ÿæˆ</li>
                        <li>ğŸ“– å•é¡Œæ–‡ã‚¯ãƒªãƒƒã‚¯ã§ä¾‹æ–‡è¡¨ç¤º (å…¨ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ)</li>
                        <li>ğŸ‘† å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ã§é—®é¢˜åˆ‡æ›¿ (ãƒ¢ãƒã‚¤ãƒ«)</li>
                        <li>ğŸ–±ï¸ ã‚«ãƒ¼ãƒ‰å·¦å³ã‚¯ãƒªãƒƒã‚¯ã§å•é¡Œåˆ‡æ›¿ (ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—)</li>
                    </ul>
                </div>
            </div>`;
            currentQuiz = [];
            currentQuestion = 0;
            score = 0;
            selectedAnswer = null;
            streak = 0;
            maxStreak = 0;
            startTime = null;
            questionStartTime = null;
            totalTime = 0;
            wrongAnswers = [];

            answerLog = [];
            maxQuestionReachedInSession = 0;
        }

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            const body = document.body;
            const button = document.querySelector('.theme-toggle');
            if (isDarkMode) {
                body.classList.add('dark-mode');
                body.classList.remove('text-gray-800');
                button.textContent = 'â˜€ï¸';
            } else {
                body.classList.remove('dark-mode');
                body.classList.add('text-gray-800');
                button.textContent = 'ğŸŒ™';
            }
            if (document.body.classList.contains('quiz-mode-active') && currentQuiz.length > 0 && currentQuestion < currentQuiz.length) {
                const tempSelected = selectedAnswer;
                const tempCurrentQ = currentQuestion;

                showQuestion();

                const isViewingPast = answerLog.find(log => log.questionIndex === tempCurrentQ);
                if (!isViewingPast && tempSelected !== null) {
                    selectedAnswer = tempSelected;
                    const options = document.querySelectorAll('.option');
                    if (options[selectedAnswer] && !options[selectedAnswer].disabled) {
                        options[selectedAnswer].classList.add('selected-option');
                        options[selectedAnswer].classList.add('bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white');
                        options[selectedAnswer].style.borderColor = isDarkMode ? '#a78bfa' : '#818cf8';
                    }
                } else {
                    selectedAnswer = null;
                }
            }
        }

        async function generateExampleSentence(buttonElement, word, reading, meaning) {
            buttonElement.disabled = true;
            buttonElement.textContent = 'ç”Ÿæˆä¸­...';
            showSentenceLoadingSpinner();

            let chatHistory = [{ role: "user", parts: [{ text: `ã€Œ${word} (${reading})ã€ã¨ã„ã†æ—¥æœ¬èªã®å˜èªï¼ˆæ„å‘³ï¼š${meaning}ï¼‰ã‚’ä½¿ã£ã¦ã€JLPT N3/N2ãƒ¬ãƒ™ãƒ«ã®è‡ªç„¶ãªä¾‹æ–‡ã‚’ä¸€ã¤ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚**ä¾‹æ–‡ã®ã¿ã‚’æ—¥æœ¬èªã§æä¾›ã—ã€èª¬æ˜ã‚„ä»–ã®ãƒ†ã‚­ã‚¹ãƒˆã¯ä¸€åˆ‡å«ã‚ãªã„ã§ãã ã•ã„ã€‚**` }] }];
            const payload = { contents: chatHistory };
            const apiKey = "YOUR_GEMINI_API_KEY"; 

            if (apiKey === "YOUR_GEMINI_API_KEY" || apiKey === "") {
                showGeneratedSentenceModal('APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
                console.error('Gemini API key is not set.');
                buttonElement.disabled = false;
                buttonElement.innerHTML = 'âœ¨ æ–°ã—ã„ä¾‹æ–‡ã‚’ç”Ÿæˆ';
                const spinner = document.getElementById('sentenceLoadingSpinner');
                if (spinner) spinner.classList.add('hidden');
                return;
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorResult = await response.json().catch(() => ({ error: { message: 'Unknown API error format.' } }));
                    console.error('Gemini API error response:', errorResult);
                    throw new Error(`Gemini API request failed: ${response.status} ${response.statusText}. ${errorResult.error?.message || ''}`);
                }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const sentence = result.candidates[0].content.parts[0].text.trim();
                    showGeneratedSentenceModal(sentence);
                } else {
                    showGeneratedSentenceModal('ä¾‹æ–‡ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚APIã‹ã‚‰ã®å¿œç­”å½¢å¼ãŒäºˆæœŸã—ãªã„ã‚‚ã®ã§ã™ã€‚');
                    console.error('Gemini API response structure unexpected:', result);
                }
            } catch (error) {
                showGeneratedSentenceModal(`ä¾‹æ–‡ã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚`);
                console.error('Error calling Gemini API:', error);
            } finally {
                buttonElement.disabled = false;
                buttonElement.innerHTML = 'âœ¨ æ–°ã—ã„ä¾‹æ–‡ã‚’ç”Ÿæˆ';
            }
        }

        // --- Navigation Helper Functions ---
        function navigateToPreviousQuestion() {
            // Check if navigation is appropriate (not while an answer is being processed for a new question)
            const currentQuestionHasBeenAnswered = answerLog.find(log => log.questionIndex === currentQuestion);
            if (selectedAnswer !== null && !currentQuestionHasBeenAnswered) {
                 return;
            }

            if (currentQuestion > 0) {
                currentQuestion--;
                selectedAnswer = null; // Reset selection state as we are navigating
                showQuestion();
            }
        }

        function navigateToNextQuestion() {
            // Check if navigation is appropriate
            const currentQuestionHasBeenAnswered = answerLog.find(log => log.questionIndex === currentQuestion);
            if (selectedAnswer !== null && !currentQuestionHasBeenAnswered) {
                 return;
            }

            if (currentQuestion < currentQuiz.length - 1) {
                const targetQuestionIndex = currentQuestion + 1;
                // Allow navigation if:
                // 1. The target question is within the already "reached" part of the quiz.
                // "Reached" means maxQuestionReachedInSession has been updated to at least this index,
                // typically after answering the question before it.
                if (targetQuestionIndex <= maxQuestionReachedInSession) {
                    currentQuestion = targetQuestionIndex;
                    selectedAnswer = null; // Reset selection state
                    showQuestion();
                }
                // Note: Users cannot use click/swipe to advance to a *brand new, unanswered* question.
                // That only happens via submitAnswer() -> nextQuestion().
            }
        }

        // --- Event Handlers for Navigation ---
        function handleTouchStart(event) {
            const currentQuestionHasBeenAnswered = answerLog.find(log => log.questionIndex === currentQuestion);
            if (!document.body.classList.contains('quiz-mode-active') || (selectedAnswer !== null && !currentQuestionHasBeenAnswered)) {
                touchstartX = 0; // Prevent swipe processing
                return;
            }
            touchstartX = event.changedTouches[0].screenX;
            touchstartY = event.changedTouches[0].screenY;
        }

        function handleTouchMove(event) {
            if (touchstartX === 0) return; // Swipe not initiated or blocked

            const currentX = event.changedTouches[0].screenX;
            const currentY = event.changedTouches[0].screenY;
            const deltaX = currentX - touchstartX;
            const deltaY = currentY - touchstartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) { // Prefer horizontal swipe
                event.preventDefault();
            }
        }

        function handleTouchEnd(event) {
            if (touchstartX === 0) return; // Swipe not initiated or blocked

            touchendX = event.changedTouches[0].screenX;
            touchendY = event.changedTouches[0].screenY;
            handleSwipeGesture();
            touchstartX = 0; // Reset for next swipe
            touchstartY = 0;
        }

        function handleSwipeGesture() {
            const deltaX = touchendX - touchstartX;
            const deltaY = touchendY - touchstartY;

            if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX < 0) { // Swipe Left (Next Question)
                    navigateToNextQuestion();
                } else if (deltaX > 0) { // Swipe Right (Previous Question)
                    navigateToPreviousQuestion();
                }
            }
        }

        function handleCardClick(event) {
            const currentQuestionHasBeenAnswered = answerLog.find(log => log.questionIndex === currentQuestion);
            
            if (!document.body.classList.contains('quiz-mode-active') || 
                (selectedAnswer !== null && !currentQuestionHasBeenAnswered)) {
                return;
            }

            const target = event.target;
            if (target.closest('.option') ||
                target.closest('.exit-btn') ||
                target.closest('#questionText') || 
                target.closest('.feedback') ||
                target.closest('.progress-container') ||
                target.closest('.stats')) {
                return; 
            }

            const optionsDiv = quizContainerElement.querySelector('.options');
            if (optionsDiv) {
                const optionsRect = optionsDiv.getBoundingClientRect();
                if (event.clientY >= optionsRect.top) { 
                    return; 
                }
            }

            if (!quizContainerElement) return;
            const rect = quizContainerElement.getBoundingClientRect();
            const clickX = event.clientX - rect.left; 
            const elementWidth = rect.width;
            
            // å®šä¹‰å¯ç‚¹å‡»çš„å³ä¾§åŒºåŸŸï¼šå¡ç‰‡å®½åº¦çš„å30%
            const clickZoneWidth = elementWidth * 0.30; 

            // åªå¤„ç†ç‚¹å‡»å³ä¾§åŒºåŸŸ (ä¸‹ä¸€é¢˜)
            if (clickX > (elementWidth - clickZoneWidth)) { 
                navigateToNextQuestion();
            }
            // å·¦ä¾§ç‚¹å‡»ä¸å†å¤„ç†
        }

    </script>

</body>

</html>