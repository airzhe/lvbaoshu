<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <!-- Title will be set by JavaScript -->
    <title>単語練習</title>
    <!--
    <script src="./tailwind.css"></script>
    -->
     <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* === 主题颜色和背景 === */
            --body-bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --body-text-color: #2d3748;
            /* 基础文本颜色 (深灰，Tailwind gray-800 类似) */
            --container-bg: rgba(255, 255, 255, 0.95);
            --container-border-color: rgba(255, 255, 255, 0.2);
            --container-text-color: inherit;
            /* 继承 body 或特定颜色 */


            --controls-bg-white-override: initial;

            --gradient-text-bg: linear-gradient(45deg, #667eea, #764ba2);

            --btn-before-bg: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);

            --exit-btn-bg: linear-gradient(to bottom right, #e5e7eb, #d1d5db);
            --exit-btn-text-color: #374151;
            --exit-btn-hover-bg: linear-gradient(to bottom right, #d1d5db, #b3b7c1);

            --progress-bar-bg: #e9d5ff;
            /* 浅色模式进度条背景 (Tailwind purple-200 类似) */
            --progress-fill-bg: linear-gradient(to right, #3b82f6, #8b5cf6);

            --option-bg: rgba(255, 255, 255, 0.8);
            --option-border-color: #93c5fd;
            /* Tailwind blue-300 */
            --option-text-color: inherit;
            --option-hover-bg: rgba(239, 246, 255, 0.95);
            --option-hover-border-color: #818cf8;
            --option-hover-text-color: var(--text-body);

            --feedback-text-color-default: #374151;
            /* Tailwind gray-700 */

            --text-green-600-val: #059669;
            --text-red-600-val: #dc2626;
            --text-red-500-val: #ef4444;
            --text-orange-500-val: #f97316;
            --text-gray-900-val: #111827;
            --text-color-example-sentence-val: #4b5563;
            /* Tailwind gray-700 */

            --glass-morphism-bg: rgba(233, 236, 241, 0.6);
            /* Tailwind gray-100 with opacity (for .features bg-indigo-100) */
            --glass-morphism-border: 1px solid rgba(229, 231, 235, 0.5);
            /* Tailwind gray-200 with opacity */
            --glass-morphism-header-text: #4f46e5;
            /* Tailwind indigo-600 for .features h3 */

            /* 反馈特定颜色 (浅色) */
            --feedback-green-text: var(--text-green-600-val);
            --feedback-green-bg: rgba(220, 252, 231, 0.9);
            /* Tailwind green-100, more opaque */
            --feedback-green-border: rgba(110, 231, 183, 0.7);
            /* Tailwind green-300, more opaque */
            --feedback-green-shadow: 0 4px 12px rgba(52, 211, 153, 0.15);

            --feedback-red-text: var(--text-red-600-val);
            --feedback-red-bg: rgba(254, 226, 226, 0.9);
            /* Tailwind red-100, more opaque */
            --feedback-red-border: rgba(252, 165, 165, 0.7);
            /* Tailwind red-300, more opaque */
            --feedback-red-shadow: 0 4px 12px rgba(248, 113, 113, 0.15);

            --immersive-quiz-container-bg: rgba(255, 255, 255, 0.25);
            /* from your original */
        }

        body.dark-mode {
            --body-bg-gradient: linear-gradient(135deg, #1a2634 0%, #2c3e50 100%);
            --body-text-color: #e2e8f0;
            /* Tailwind slate-200 */
            --container-bg: rgba(45, 55, 72, 0.95);
            /* Tailwind slate-700 */
            --container-border-color: rgba(255, 255, 255, 0.3);
            --container-text-color: #e2e8f0;

            --controls-bg-white-override: rgba(255, 255, 255, 0.1);

            /* --gradient-text-bg: linear-gradient(45deg, #93c5fd, #c4b5fd); */

            --btn-before-bg: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);

            --exit-btn-bg: linear-gradient(to bottom right, #4b5563, #6b7280);
            --exit-btn-text-color: #e2e8f0;
            --exit-btn-hover-bg: linear-gradient(to bottom right, #6b7280, #9ca3af);

            --progress-bar-bg: #4b5563;
            /* Tailwind gray-600 */
            /* --progress-fill-bg: linear-gradient(to right, #3b82f6, #8b5cf6); /* 保持不变或按需修改 */

            --option-bg: rgba(55, 65, 81, 0.8);
            /* Tailwind gray-700 */
            --option-border-color: #60a5fa;
            /* Tailwind blue-400 */
            --option-text-color: #e2e8f0;
            --option-hover-bg: rgba(69, 71, 90, 0.9);
            /* 例如：Catppuccin Surface1，比基础背景稍亮 */
            --option-hover-border-color: #89b4fa;
            --option-hover-text-color: var(--text-body);

            --text-green-600-val: #34d399;
            --text-red-600-val: #f87171;
            /* Note: original was text-red-600, but value seems for text-red-400/500 */
            --text-red-500-val: #f87171;
            --text-orange-500-val: #fb923c;
            --text-gray-900-val: #e2e8f0;
            --text-color-example-sentence-val: #cbd5e1;
            /* Tailwind slate-300 */

            --glass-morphism-bg: rgba(45, 55, 72, 0.6);
            /* Tailwind slate-700 with opacity (for .features dark:bg-indigo-900 dark:bg-opacity-40) */
            --glass-morphism-border: 1px solid rgba(255, 255, 255, 0.15);
            --glass-morphism-header-text: #818cf8;
            /* Tailwind indigo-400 for .features h3 dark:text-indigo-400 */

            /* 反馈特定颜色 (深色) */
            --feedback-green-text: #6ee7b7;
            --feedback-green-bg: rgba(16, 185, 129, 0.8);
            --feedback-green-border: rgba(52, 211, 153, 0.5);
            --feedback-green-shadow: 0 4px 12px rgba(52, 211, 153, 0.25);

            --feedback-red-text: #fca5a5;
            --feedback-red-bg: rgba(220, 38, 38, 0.8);
            --feedback-red-border: rgba(248, 113, 113, 0.5);
            --feedback-red-shadow: 0 4px 12px rgba(248, 113, 113, 0.25);

            --immersive-quiz-container-bg: rgba(30, 41, 59, 0.6);
            /* dark variant of your original, slate-800 like*/

        }

        /* --- 基础和组件样式 --- */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background: var(--body-bg-gradient);
            color: var(--body-text-color);
            transition: background 0.5s ease, color 0.5s ease;
            overscroll-behavior-y: contain;
        }

        .header,
        .controls,
        .quiz-container:not(.immersive-active) {
            /* Exclude immersive for its own bg */
            background: var(--container-bg);
            /* border-color: var(--container-border-color); Apply if these elements have a border styled e.g., border: 1px solid; */
            color: var(--container-text-color);
        }

        body.dark-mode .controls .bg-white {
            /* Handles Tailwind .bg-white inside .controls */
            background: var(--controls-bg-white-override) !important;
            /* Important if .bg-white has high specificity */
        }

        .gradient-text {
            background: var(--gradient-text-bg);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--btn-before-bg);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .exit-btn {
            position: absolute;
            top: calc(env(safe-area-inset-top, 0px) + 0.75rem);
            right: 0.75rem;
            width: 2.5rem;
            height: 2.5rem;
            background: var(--exit-btn-bg);
            color: var(--exit-btn-text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9999px;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease, color 0.3s ease, transform 0.3s ease;
            z-index: 50;
        }

        .exit-btn:hover {
            background: var(--exit-btn-hover-bg);
            transform: scale(1.05);
        }

        .exit-btn:active {
            transform: scale(0.95);
        }

        .theme-toggle {
            z-index: 50;
            /* Base styles for theme-toggle if not covered by Tailwind and needed here */
        }

        body.quiz-mode-active .theme-toggle {
            display: none !important;
        }

        .progress-bar {
            background: var(--progress-bar-bg);
            width: 100%;
            height: 0.625rem;
            /* 2.5 in Tailwind, h-2.5 */
            border-radius: 0.375rem;
            /* rounded-md */
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            background: var(--progress-fill-bg);
            height: 100%;
            border-radius: 0.375rem;
            /* rounded-md */
            transition: width 0.5s ease-in-out;
            /* width comes from JS style */
            position: relative;
            /* For ::after positioning */
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image: linear-gradient(-45deg,
                    rgba(255, 255, 255, 0.2) 25%,
                    transparent 25%,
                    transparent 50%,
                    rgba(255, 255, 255, 0.2) 50%,
                    rgba(255, 255, 255, 0.2) 75%,
                    transparent 75%,
                    transparent);
            background-size: 30px 30px;
            animation: move 2s linear infinite;
        }

        @keyframes move {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 30px 30px;
            }
        }

        .option {
            position: relative;
            overflow: hidden;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            background: var(--option-bg);
            border-color: var(--option-border-color);
            /* Needs 'border-width' and 'border-style' to be visible */
            color: var(--option-text-color);
            /* Ensure other Tailwind classes like p-*, rounded-*, border-2 are on the HTML element */
        }

        @media (hover: hover) and (pointer: fine) {
            .option:hover:not(:disabled) {
                background-color: var(--option-hover-bg);
                border-color: var(--option-hover-border-color);
                color: var(--option-hover-text-color);
            }
        }

        .option.selected-option {
            border-width: 2px;
            /* This makes the border visible if other border properties are set */
        }

        /* 新增: 禁用选项的样式 */
        .option:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }


        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes incorrectShake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-4px);
            }

            75% {
                transform: translateX(4px);
            }
        }

        body.quiz-mode-active .container {
            padding: 0;
            max-width: 100%;
            height: 100dvh;
            /* Use dvh for dynamic viewport height */
            display: flex;
        }

        #quizContainer.immersive-active {
            width: 100%;
            height: 100dvh;
            min-height: 100dvh;
            margin: 0 !important;
            border-radius: 0;
            box-shadow: none;
            padding-top: calc(env(safe-area-inset-top, 0px) + 1.5rem) !important;
            padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 0.5rem) !important;
            padding-left: 1rem !important;
            padding-right: 1rem !important;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            position: relative;
            background: var(--immersive-quiz-container-bg);
        }

        #quizContainer.immersive-active>div:not(.progress-container):not(.stats):not(.options):not(.feedback):not(.question-area-wrapper) {
            flex-grow: 1;
        }

        #quizContainer.immersive-active .question-area-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding-top: 8rem;
            align-items: center;
        }

        #quizContainer.immersive-active .question-content-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #quizContainer.immersive-active .options {
            margin-top: auto;
            padding-bottom: 2rem;
            width: 100%;
        }

        #quizContainer.immersive-active .feedback {
            position: absolute;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 1.5rem);
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            margin-top: 0;
            margin-bottom: 0;
            z-index: 100;
            visibility: hidden;
            /* Controlled by JS */
        }

        .header.hidden-during-quiz,
        .controls.hidden-during-quiz {
            display: none !important;
        }

        .feedback {
            text-align: center;
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.2s ease-out;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            word-break: break-word;
            color: var(--feedback-text-color-default);
            /* Other base styles for feedback like padding, border-radius if not handled by Tailwind */
        }

        /* Assumes JS adds 'text-green-600' or 'text-red-600' for feedback states */
        .feedback.text-green-600 {
            color: var(--feedback-green-text) !important;
            /* Important to override Tailwind if needed */
            background-color: var(--feedback-green-bg);
            border-color: var(--feedback-green-border);
            /* Needs border-width and style */
            box-shadow: var(--feedback-green-shadow);
        }

        .feedback.text-red-600 {
            color: var(--feedback-red-text) !important;
            /* Important to override Tailwind if needed */
            background-color: var(--feedback-red-bg);
            border-color: var(--feedback-red-border);
            /* Needs border-width and style */
            box-shadow: var(--feedback-red-shadow);
        }

        /* For .features div in welcome message */
        .features.glass-morphism {
            background: var(--glass-morphism-bg);
            border: var(--glass-morphism-border);
            /* color for text inside .features.glass-morphism ul li can inherit or be set */
        }

        .features.glass-morphism h3 {
            color: var(--glass-morphism-header-text);
        }


        .feedback small {
            display: block;
            margin-top: 0.5rem;
            line-height: 1.4;
            /* color for small text can also be a variable */
        }

        /* Stats colors - these override Tailwind text color classes in dark mode */
        body.dark-mode .stats .score.text-green-600 {
            color: var(--text-green-600-val) !important;
        }

        body.dark-mode .stats .streak-counter.text-red-500 {
            color: var(--text-red-500-val) !important;
        }

        body.dark-mode .stats .timer.text-orange-500 {
            color: var(--text-orange-500-val) !important;
        }

        /* Question text color */
        body.dark-mode .question.text-gray-900 {
            /* Handles custom .question with Tailwind .text-gray-900 */
            color: var(--text-gray-900-val) !important;
        }

        #exampleSentenceDisplay {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out;
            word-break: normal;
            line-height: 1.6;
            text-align: center;
            margin-top: 0;
            color: var(--text-color-example-sentence-val);
        }

        #exampleSentenceDisplay.visible {
            max-height: 10em;
            opacity: 1;
            margin-top: 0.5rem;
        }

        /* Option selection gradient overrides for dark mode - specific to your JS logic */
        body.dark-mode .option.bg-gradient-to-br.from-indigo-500.to-purple-600 {
            background: linear-gradient(to bottom right, #60a5fa, #a78bfa);
        }

        body.dark-mode .option.bg-gradient-to-br.from-green-500.to-lime-600 {
            background: linear-gradient(to bottom right, #34d399, #86efac);
        }

        body.dark-mode .option.bg-gradient-to-br.from-red-500.to-orange-500 {
            background: linear-gradient(to bottom right, #f87171, #fb923c);
        }

        #keyboardHint {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 1rem);
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            opacity: 0;
            /* Controlled by JS */
            transition: opacity 0.3s ease;
            z-index: 50;
        }
    </style>

</head>

<body class="min-h-screen text-gray-800 relative">
    <button
        class="theme-toggle fixed top-5 right-5 bg-white bg-opacity-90 rounded-full w-12 h-12 flex items-center justify-center text-2xl cursor-pointer shadow-md transition-all duration-300 hover:scale-110 hover:shadow-lg z-50"
        onclick="toggleTheme()">🌙</button>

    <div class="container mx-auto p-5 max-w-4xl">
        <div
            class="header bg-opacity-95 backdrop-blur-md rounded-2xl p-8 mb-8 text-center shadow-lg border border-white border-opacity-20 animate-[slideDown_0.8s_ease]">
            <!-- H1 will be set by JavaScript -->
            <h1 class="text-4xl font-bold mb-2 gradient-text">語彙練習</h1>
            <p class="text-gray-600 text-lg">日本語能力試験スタイル語彙練習</p>
        </div>

        <div
            class="controls bg-opacity-95 backdrop-blur-md rounded-xl p-5 mb-8 flex flex-wrap gap-4 items-center justify-center shadow-lg border border-white border-opacity-20 animate-[slideUp_0.8s_ease]">
            <div class="lesson-selector flex items-center gap-2">
                <label for="lesson" class="font-semibold text-indigo-600">レッスン:</label>
                <select id="lesson"
                    class="p-2.5 rounded-lg border-2 border-indigo-300 bg-white text-base cursor-pointer transition-all duration-300 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100">
                    <option value="all">全てのレッスン</option>
                </select>
            </div>
            <div class="mode-selector flex items-center gap-2">
                <label for="mode" class="font-semibold text-indigo-600">練習モード:</label>
                <select id="mode"
                    class="p-2.5 rounded-lg border-2 border-indigo-300 bg-white text-base cursor-pointer transition-all duration-300 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100">
                    <option value="reading">読み方</option>
                    <option value="meaning">意味</option>
                    <option value="usage">使い方</option>
                    <option value="mixed">ミックス</option>
                </select>
            </div>
            <div class="difficulty-selector flex items-center gap-2">
                <label for="difficulty" class="font-semibold text-indigo-600">問題数:</label>
                <select id="difficulty"
                    class="p-2.5 rounded-lg border-2 border-indigo-300 bg-white text-base cursor-pointer transition-all duration-300 focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-100">
                    <option value="5">5問</option>
                    <option value="10">10問</option>
                    <option value="20" selected>20問</option>
                    <option value="30">30問</option>
                    <option value="all">全て</option>
                </select>
            </div>
            <div>
                <button id="startQuizButton"
                    class="btn relative overflow-hidden bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0 disabled:opacity-60 disabled:cursor-not-allowed"
                    onclick="startQuiz()" disabled>練習開始</button>
                <button
                    class="btn secondary relative overflow-hidden bg-gradient-to-br from-red-500 to-orange-500 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0 disabled:opacity-60 disabled:cursor-not-allowed"
                    onclick="resetQuiz()">リセット</button>
            </div>
        </div>

        <div class="quiz-container bg-opacity-95 backdrop-blur-md rounded-2xl p-10 shadow-lg border border-white border-opacity-20 min-h-[400px] animate-[fadeIn_0.5s_ease]"
            id="quizContainer">
            <div class="welcome-message">
                <h2 class="text-center text-2xl font-bold mb-5">練習モードを選んで開始してください</h2>
                <p class="text-center text-gray-600 dark:text-gray-300 text-lg mb-8">
                    <strong>読み方:</strong> 漢字の読みを選択<br>
                    <strong>意味:</strong> 単語の意味を選択<br>
                    <strong>使い方:</strong> 文脈に合う単語を選択<br>
                    <strong>ミックス:</strong> 全種類の問題をランダムに<br>
                </p>
                <div
                    class="features glass-morphism mt-8 p-5 bg-indigo-100 dark:bg-indigo-900 dark:bg-opacity-40 rounded-xl">
                    <h3 class="text-center text-xl font-semibold mb-4 text-indigo-600 dark:text-indigo-400">✨ 新機能</h3>
                    <ul class="text-left text-gray-600 dark:text-gray-300 leading-relaxed list-none list-inside">
                        <li>🎯 問題数選択（5/10/30/全て）</li>
                        <li>🔥 連続正解カウンター</li>
                        <li>⏱️ 問題別タイマー</li>
                        <li>🌙 ダークモード対応</li>
                        <li>⌨️ キーボードショートカット</li>
                        <li>📱 完全レスポンシブ対応</li>
                        <li>📚 レッスン選択機能</li>
                        <li>🇨🇳 意味練習で中国語表示</li>
                        <li>✨ AIによる新しい例文生成</li>
                        <li>📖 問題文クリックで例文表示 (全モード対応)</li>
                        <li>👆 左右スワイプで问题切替 (モバイル)</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="keyboard-shortcut fixed bottom-5 right-5 bg-gray-800 text-white py-2.5 px-4 rounded-xl text-xs opacity-0 transition-opacity duration-300 z-50"
        id="keyboardHint">
        キーボード: 1-4で選択, Enterで確定
    </div>

    <div id="messageBox" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="messageBoxText" class="text-lg font-semibold mb-4"></p>
            <button
                class="btn bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-2 px-4 rounded-full"
                onclick="hideMessageBox()">OK</button>
        </div>
    </div>

    <div id="generatedSentenceModal"
        class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[60] hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-lg w-full text-center">
            <h3 class="text-xl font-bold mb-4 text-indigo-700">✨ 新しい例文</h3>
            <p id="generatedSentenceText" class="text-lg text-gray-800 mb-4"></p>
            <div id="sentenceLoadingSpinner" class="hidden">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-500 mx-auto"></div>
                <p class="text-gray-600 text-sm mt-2">生成中...</p>
            </div>
            <button
                class="btn bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-2 px-4 rounded-full"
                onclick="hideGeneratedSentenceModal()">閉じる</button>
        </div>
    </div>

    <script>
        let allVocabulary = {};
        let currentQuiz = [];
        let currentQuestion = 0;
        let score = 0;
        let selectedAnswer = null;
        let quizMode = 'reading';
        let streak = 0;
        let maxStreak = 0;
        let startTime = null;
        let questionStartTime = null;
        let totalTime = 0;
        let wrongAnswers = [];
        let isDarkMode = false;
        let timerInterval;

        let headerElement;
        let controlsElement;
        let quizContainerElement;
        let mainContainerElement;
        let startQuizButton;
        let lessonSelectElement;
        let currentJLPTLevel = 'N2'; // Default level

        // --- 滑动功能相关变量 ---
        let touchstartX = 0;
        let touchendX = 0;
        let touchstartY = 0;
        let touchendY = 0;
        const swipeThreshold = 50; // 滑动最小像素阈值

        // --- 新增: 记录答题历史和最远进度的变量 ---
        let answerLog = []; // 存储每道题的作答情况
        let maxQuestionReachedInSession = 0; // 本轮测验中用户达到过的最远题目索引 (已回答或正在回答)


        async function loadVocabularyData(fileNameToLoad) {
            try {
                if (!startQuizButton) {
                    startQuizButton = document.getElementById('startQuizButton');
                }
                if (startQuizButton) startQuizButton.disabled = true;

                const response = await fetch(fileNameToLoad);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching ${fileNameToLoad}`);
                }
                allVocabulary = await response.json();
                console.log(`Vocabulary for ${currentJLPTLevel} loaded successfully from ${fileNameToLoad}:`, allVocabulary);
                populateLessonSelect();
                if (startQuizButton) startQuizButton.disabled = false;
            } catch (error) {
                console.error(`Could not load vocabulary from ${fileNameToLoad}:`, error);
                showMessageBox(`語彙データ(${fileNameToLoad})の読み込みに失敗しました。ファイルが存在するか、内容が正しいJSON形式か確認してください。`);
                if (startQuizButton) startQuizButton.disabled = true;
            }
        }

        function initializeApp() {
            const urlParams = new URLSearchParams(window.location.search);
            const levelParam = urlParams.get('level');
            const allowedLevels = ['n1', 'n2', 'n3'];

            let determinedLevel = 'n2';

            if (levelParam && allowedLevels.includes(levelParam.toLowerCase())) {
                determinedLevel = levelParam.toLowerCase();
            } else if (levelParam) {
                console.warn(`Invalid level parameter '${levelParam}' provided. Defaulting to N2.`);
            }

            currentJLPTLevel = determinedLevel.toUpperCase();
            const jsonFileName = `${determinedLevel}.json`;

            document.title = `新無敵緑宝書${currentJLPTLevel}単語練習`;
            const h1Element = document.querySelector('.header h1.gradient-text');
            if (h1Element) {
                h1Element.textContent = `新無敵緑宝書${currentJLPTLevel}語彙練習`;
            }

            loadVocabularyData(jsonFileName);
        }

        function populateLessonSelect() {
            if (!lessonSelectElement) return;
            lessonSelectElement.innerHTML = '<option value="all">全てのレッスン</option>';

            const lessonKeys = Object.keys(allVocabulary);
            lessonKeys.sort((a, b) => {
                const numA = parseInt(a.replace('lesson', ''), 10);
                const numB = parseInt(b.replace('lesson', ''), 10);
                return numA - numB;
            });

            lessonKeys.forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key.replace('lesson', 'レッスン');
                lessonSelectElement.appendChild(option);
            });
        }


        document.addEventListener('DOMContentLoaded', () => {
            headerElement = document.querySelector('.header');
            controlsElement = document.querySelector('.controls');
            quizContainerElement = document.getElementById('quizContainer');
            mainContainerElement = document.querySelector('.container');
            startQuizButton = document.getElementById('startQuizButton');
            lessonSelectElement = document.getElementById('lesson');

            initializeApp();

            const difficultySelect = document.getElementById('difficulty');
            if (difficultySelect) {
                difficultySelect.value = "20";
            }
        });

        function showMessageBox(message) {
            document.getElementById('messageBoxText').textContent = message;
            document.getElementById('messageBox').classList.remove('hidden');
        }

        function hideMessageBox() {
            document.getElementById('messageBox').classList.add('hidden');
        }

        function showGeneratedSentenceModal(sentence) {
            document.getElementById('generatedSentenceText').textContent = sentence;
            document.getElementById('sentenceLoadingSpinner').classList.add('hidden');
            document.getElementById('generatedSentenceModal').classList.remove('hidden');
        }

        function hideGeneratedSentenceModal() {
            document.getElementById('generatedSentenceModal').classList.add('hidden');
            document.getElementById('generatedSentenceText').textContent = '';
        }

        function showSentenceLoadingSpinner() {
            document.getElementById('generatedSentenceText').textContent = '';
            document.getElementById('sentenceLoadingSpinner').classList.remove('hidden');
            document.getElementById('generatedSentenceModal').classList.remove('hidden');
        }

        document.addEventListener('keydown', (e) => {
            // 如果弹窗显示，或者当前题目是查看历史答案（选项被禁用），则不处理键盘事件
            if (!document.getElementById('messageBox').classList.contains('hidden') ||
                !document.getElementById('generatedSentenceModal').classList.contains('hidden')) {
                return;
            }

            const optionsElements = document.querySelectorAll('.option');
            const isViewingPastAnswer = optionsElements.length > 0 && optionsElements[0].disabled;

            if (isViewingPastAnswer && e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') { // 历史查看模式下只允许左右箭头
                return;
            }
            if (selectedAnswer !== null && !isViewingPastAnswer) { // 正常答题时，选了答案后只响应Enter
                if (e.key === 'Enter') submitAnswer();
                return;
            }
            if (isViewingPastAnswer && (e.key === 'Enter' || (e.key >= '1' && e.key <= '4'))) { // 历史查看模式不响应数字和Enter
                return;
            }


            const key = e.key;
            if (key >= '1' && key <= '4' && !isViewingPastAnswer) {
                const index = parseInt(key) - 1;
                if (optionsElements[index] && !optionsElements[index].disabled) {
                    selectAnswer(index);
                }
            } else if (key === 'Enter' && selectedAnswer !== null && !isViewingPastAnswer) {
                submitAnswer();
            }
            // 左右箭头滑动由 swipe gesture 函数处理，这里不再重复
        });

        function showKeyboardHint() {
            const hint = document.getElementById('keyboardHint');
            hint.classList.add('opacity-100');
            setTimeout(() => {
                hint.classList.remove('opacity-100');
            }, 3000);
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function isReadingSameAsWord(vocab) {
            return vocab.w === vocab.r;
        }

        function generateQuestion(vocab, mode, allAvailableVocab) {
            const correctAnswer = vocab;
            let otherVocab = allAvailableVocab.filter(v => v.w !== vocab.w);
            if (otherVocab.length < 3) {
                const needed = 3 - otherVocab.length;
                for (let i = 0; i < needed; i++) {
                    let randomVocab;
                    do {
                        randomVocab = allAvailableVocab[Math.floor(Math.random() * allAvailableVocab.length)];
                    } while (randomVocab.w === vocab.w || otherVocab.some(ov => ov.w === randomVocab.w));
                    if (randomVocab) otherVocab.push(randomVocab);
                }
                otherVocab = otherVocab.filter(v => v.w !== vocab.w).slice(0, 3);
            }

            const wrongAnswersPool = shuffleArray(otherVocab).slice(0, 3);
            while (wrongAnswersPool.length < 3) {
                let randomFallback = allAvailableVocab[Math.floor(Math.random() * allAvailableVocab.length)];
                if (randomFallback.w !== vocab.w && !wrongAnswersPool.some(w => w.w === randomFallback.w)) {
                    wrongAnswersPool.push(randomFallback);
                } else if (randomFallback.w !== vocab.w) {
                    wrongAnswersPool.push(randomFallback);
                } else if (allAvailableVocab.length > 1) {
                    let anotherFallback;
                    do {
                        anotherFallback = allAvailableVocab[Math.floor(Math.random() * allAvailableVocab.length)];
                    } while (anotherFallback.w === vocab.w && allAvailableVocab.length > 1);
                    wrongAnswersPool.push(anotherFallback);
                } else {
                    wrongAnswersPool.push({ w: "---", r: "---", m: "---", c: "---" });
                }
            }


            if (mode === 'reading') {
                if (isReadingSameAsWord(vocab)) {
                    console.warn(`Skipping reading question for word where reading is same as word: ${vocab.w}. Falling back to meaning.`);
                    const meaningQuestion = generateQuestion(vocab, 'meaning', allAvailableVocab);
                    if (meaningQuestion) {
                        meaningQuestion.originalIntendedMode = 'reading';
                    }
                    return meaningQuestion;
                }
                return {
                    question: vocab.w,
                    options: shuffleArray([
                        { text: correctAnswer.r, correct: true },
                        { text: wrongAnswersPool[0] ? wrongAnswersPool[0].r : '---', correct: false },
                        { text: wrongAnswersPool[1] ? wrongAnswersPool[1].r : '---', correct: false },
                        { text: wrongAnswersPool[2] ? wrongAnswersPool[2].r : '---', correct: false }
                    ]),
                    correctAnswer: correctAnswer.r,
                    vocab: vocab,
                    mode: 'reading'
                };
            } else if (mode === 'meaning') {
                const correctMeaning = correctAnswer.c || correctAnswer.m;
                const wrongMeaning1 = wrongAnswersPool[0] ? (wrongAnswersPool[0].c || wrongAnswersPool[0].m) : '---';
                const wrongMeaning2 = wrongAnswersPool[1] ? (wrongAnswersPool[1].c || wrongAnswersPool[1].m) : '---';
                const wrongMeaning3 = wrongAnswersPool[2] ? (wrongAnswersPool[2].c || wrongAnswersPool[2].m) : '---';
                return {
                    question: vocab.w + (vocab.w !== vocab.r ? ' (' + vocab.r + ')' : ''),
                    options: shuffleArray([
                        { text: correctMeaning, correct: true },
                        { text: wrongMeaning1, correct: false },
                        { text: wrongMeaning2, correct: false },
                        { text: wrongMeaning3, correct: false }
                    ]),
                    correctAnswer: correctMeaning,
                    vocab: vocab,
                    mode: 'meaning'
                };
            } else { // usage mode
                if (!vocab.u) {
                    console.warn(`Skipping usage question for word: ${vocab.w} (no usage provided). Falling back to meaning.`);
                    return generateQuestion(vocab, 'meaning', allAvailableVocab);
                }
                return {
                    question: vocab.u,
                    options: shuffleArray([
                        { text: correctAnswer.w, correct: true },
                        { text: wrongAnswersPool[0] ? wrongAnswersPool[0].w : '---', correct: false },
                        { text: wrongAnswersPool[1] ? wrongAnswersPool[1].w : '---', correct: false },
                        { text: wrongAnswersPool[2] ? wrongAnswersPool[2].w : '---', correct: false }
                    ]),
                    correctAnswer: correctAnswer.w,
                    vocab: vocab,
                    mode: 'usage'
                };
            }
        }


        function startQuiz() {
            if (Object.keys(allVocabulary).length === 0) {
                showMessageBox(`語彙データ(${currentJLPTLevel})がまだ読み込まれていません。少々お待ちいただくか、ページを再読み込みしてください。`);
                return;
            }

            if (headerElement) headerElement.classList.add('hidden-during-quiz');
            if (controlsElement) controlsElement.classList.add('hidden-during-quiz');
            document.body.classList.add('quiz-mode-active');
            if (quizContainerElement) quizContainerElement.classList.add('immersive-active');

            const selectedLesson = document.getElementById('lesson').value;
            quizMode = document.getElementById('mode').value;
            const difficulty = document.getElementById('difficulty').value;

            let sourceVocab = [];
            if (selectedLesson === 'all') {
                for (const lessonKey in allVocabulary) {
                    if (allVocabulary.hasOwnProperty(lessonKey) && Array.isArray(allVocabulary[lessonKey])) {
                        sourceVocab = sourceVocab.concat(allVocabulary[lessonKey]);
                    }
                }
            } else {
                if (allVocabulary.hasOwnProperty(selectedLesson) && Array.isArray(allVocabulary[selectedLesson])) {
                    sourceVocab = allVocabulary[selectedLesson];
                } else {
                    showMessageBox(`レッスン "${selectedLesson}" の単語が見つかりません (${currentJLPTLevel} データ)。`);
                    resetQuizInterface();
                    return;
                }
            }

            if (sourceVocab.length === 0) {
                showMessageBox(`選択されたレッスンには単語がありません (${currentJLPTLevel} データ)。`);
                resetQuizInterface();
                return;
            }
            sourceVocab = sourceVocab.filter(item => typeof item === 'object' && item !== null && item.w);


            let questionCount;
            if (difficulty === 'all') {
                questionCount = sourceVocab.length;
            } else {
                questionCount = parseInt(difficulty);
            }

            if (sourceVocab.length < questionCount && difficulty !== 'all') {
                showMessageBox(`選択されたレッスンには ${sourceVocab.length} 個の単語しかありません。問題数を調整しました。`);
                questionCount = sourceVocab.length;
            }
            if (questionCount === 0 && sourceVocab.length > 0) {
                questionCount = Math.min(10, sourceVocab.length);
            }
            if (questionCount === 0) {
                showMessageBox('問題数が0です。問題数を選択してください。');
                resetQuizInterface();
                return;
            }


            const shuffledVocabForQuiz = shuffleArray(sourceVocab).slice(0, questionCount);

            let generatedQuestions = [];
            const modes = ['reading', 'meaning', 'usage'];

            for (const vocab of shuffledVocabForQuiz) {
                let question = null;
                if (quizMode === 'mixed') {
                    const shuffledModes = shuffleArray([...modes]);
                    for (const mode of shuffledModes) {
                        question = generateQuestion(vocab, mode, sourceVocab);
                        if (question) break;
                    }
                } else {
                    question = generateQuestion(vocab, quizMode, sourceVocab);
                }
                if (question) {
                    generatedQuestions.push(question);
                } else {
                    console.warn(`Could not generate a valid question for vocab: ${vocab.w} in mode: ${quizMode}`);
                }
            }

            currentQuiz = generatedQuestions;


            if (currentQuiz.length === 0) {
                showMessageBox('選択された条件で問題を作成できませんでした。別のモードまたはレッスンを試してください。');
                resetQuiz();
                return;
            }

            currentQuestion = 0;
            score = 0;
            streak = 0;
            maxStreak = 0;
            wrongAnswers = [];
            selectedAnswer = null;
            startTime = Date.now();
            totalTime = 0;

            // --- 新增: 初始化答题历史和最远进度 ---
            answerLog = [];
            maxQuestionReachedInSession = 0;
            // --- 结束 ---


            // --- 初始化滑动相关状态并添加监听器 ---
            touchstartX = 0;
            touchendX = 0;
            touchstartY = 0;
            touchendY = 0;
            if (quizContainerElement) {
                quizContainerElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                quizContainerElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                quizContainerElement.addEventListener('touchend', handleTouchEnd, { passive: false });
            }
            // --- 滑动功能初始化结束 ---

            showKeyboardHint();
            showQuestion();
        }

        function showQuestion() {
            if (currentQuestion >= currentQuiz.length) {
                showFinalScore();
                return;
            }

            const question = currentQuiz[currentQuestion];
            const container = quizContainerElement;

            // --- 移除: 不再在这里通过滑动更新 maxQuestionReachedInSession ---
            // maxQuestionReachedInSession 现在只在 nextQuestion() 中, 在成功回答问题后更新。
            // if (selectedAnswer === null && currentQuestion > maxQuestionReachedInSession) {
            //     maxQuestionReachedInSession = currentQuestion;
            // }
            // --- 结束移除 ---

            const isPastQuestion = currentQuestion < maxQuestionReachedInSession; // 这主要用于辅助判断，核心状态依赖 historyEntry
            const historyEntry = answerLog.find(log => log.questionIndex === currentQuestion);

            if (!historyEntry) { // 如果是新题或正在作答的题 (没有历史记录)
                questionStartTime = Date.now(); // 仅为新问题或当前问题重置开始时间
            }


            let questionTextHTML = `<div class="question text-2xl md:text-3xl mb-1 md:mb-2 font-semibold text-center text-gray-900 leading-tight" id="questionText">${question.question}</div>`;
            let exampleSentenceHTML = `<div id="exampleSentenceDisplay" class="text-gray-700 text-mi px-2"></div>`;

            container.innerHTML = `
            <button class="exit-btn" onclick="resetQuiz()">✕</button>
            <div class="progress-container mb-4 md:mb-8">
                <div class="progress-info flex justify-between mb-2 font-semibold text-indigo-600">
                    <span>${currentQuestion + 1} / ${currentQuiz.length}</span>
                </div>
                <div class="progress-bar w-full h-2.5 bg-indigo-200 rounded-md overflow-hidden relative">
                    <div class="progress-fill h-full bg-gradient-to-r from-indigo-500 to-purple-600 rounded-md transition-all duration-500 ease-in-out relative" style="width: ${(currentQuestion / currentQuiz.length) * 100}%"></div>
                </div>
            </div>
            <div class="stats flex justify-between mb-3 md:mb-5 text-sm md:text-lg font-semibold flex-wrap gap-2">
                <span class="score text-green-600 flex items-center gap-1 md:gap-2">✅ 正解: ${score}</span>
                <span class="streak-counter text-red-500 flex items-center gap-1 md:gap-2">🔥 連続: ${streak}</span>
                <span class="timer text-orange-500 flex items-center gap-1 md:gap-2">⏱️ 経過: <span id="timer">${historyEntry ? historyEntry.timeSpent : 0}</span>s</span>
            </div>
            
            <div class="question-area-wrapper">
                <div class="question-content-area">
                    ${questionTextHTML}
                    ${exampleSentenceHTML}
                </div>
            </div>

            <div class="options grid grid-cols-1 md:grid-cols-2 gap-2.5 sm:gap-3 md:gap-4">
                ${question.options.map((option, index) => `
                    <button class="option relative overflow-hidden border-2 p-3 md:p-5 rounded-xl cursor-pointer transition-all duration-300 text-base md:text-lg text-center" onclick="selectAnswer(${index})" data-index="${index}">
                        <span class="font-bold mr-2 ${isDarkMode ? 'text-indigo-300' : 'text-indigo-500'}">${index + 1}.</span>
                        ${option.text}
                    </button>
                `).join('')}
            </div>
            <div class="feedback text-center text-lg md:text-xl font-semibold"></div>
        `;

            const feedbackElement = container.querySelector('.feedback');
            const optionElements = container.querySelectorAll('.option');

            if (historyEntry) { // 如果是已回答过的问题
                clearInterval(timerInterval); // 停止计时器
                feedbackElement.className = `feedback text-center text-lg md:text-xl font-semibold p-3 md:p-4 rounded-lg ${historyEntry.isCorrect ? 'text-green-600 bg-green-50 border-2 border-green-200' : 'text-red-600 bg-red-50 border-2 border-red-200'}`;
                if (isDarkMode) {
                    if (historyEntry.isCorrect) feedbackElement.classList.add('dark:bg-green-900', 'dark:bg-opacity-30', 'dark:border-green-700');
                    else feedbackElement.classList.add('dark:bg-red-900', 'dark:bg-opacity-30', 'dark:border-red-700');
                }

                let feedbackText = historyEntry.isCorrect ? `🎉 正解！ (${historyEntry.timeSpent}秒)` : `❌ 不正解。正解は“${question.correctAnswer}”。`;
                if (!historyEntry.isCorrect && question.vocab) {
                    const displayMeaning = question.vocab.c || question.vocab.m;
                    feedbackText += `<br><small class="text-gray-600 dark:text-slate-400 opacity-90 dark:opacity-85 text-sm md:text-base">
                    ${question.vocab.w} ${question.vocab.w !== question.vocab.r ? '(' + question.vocab.r + ')' : ''} - ${displayMeaning}
                </small>`;
                }
                feedbackElement.innerHTML = feedbackText;
                feedbackElement.style.visibility = 'visible';

                optionElements.forEach((opt, i) => {
                    opt.disabled = true; // 禁用选项
                    opt.classList.remove('selected-option', 'bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white', 'border-indigo-500', 'from-green-500', 'to-lime-600', 'border-green-500', 'from-red-500', 'to-orange-500', 'border-red-500', 'animate-[incorrectShake_0.3s_ease]');
                    opt.style.borderColor = '';

                    if (question.options[i].correct) {
                        opt.classList.add('bg-gradient-to-br', 'from-green-500', 'to-lime-600', 'text-white', 'border-green-500');
                    }
                    if (i === historyEntry.selectedOptionIndex && !historyEntry.isCorrect) {
                        opt.classList.add('bg-gradient-to-br', 'from-red-500', 'to-orange-500', 'text-white', 'border-red-500');
                    } else if (i === historyEntry.selectedOptionIndex && historyEntry.isCorrect) {
                        // Already handled by correct option styling
                    }
                });

            } else { // 新问题或正在作答的问题
                if (feedbackElement) {
                    feedbackElement.style.visibility = 'hidden';
                    feedbackElement.innerHTML = '';
                }
                optionElements.forEach(opt => {
                    opt.disabled = false; // 确保选项启用
                    opt.classList.remove('selected-option', 'bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white', 'border-indigo-500', 'from-green-500', 'to-lime-600', 'border-green-500', 'from-red-500', 'to-orange-500', 'border-red-500', 'animate-[incorrectShake_0.3s_ease]');
                    opt.style.borderColor = '';
                });
                updateTimer(); // 只有新问题或当前问题才更新计时器
            }


            const questionTextElement = document.getElementById('questionText');
            const exampleSentenceDisplayElement = document.getElementById('exampleSentenceDisplay');

            if (exampleSentenceDisplayElement) {
                exampleSentenceDisplayElement.classList.remove('visible');
                exampleSentenceDisplayElement.textContent = '';
            }

            const canShowExampleOnClick = question.vocab && question.vocab.e;

            if (questionTextElement && exampleSentenceDisplayElement && canShowExampleOnClick) {
                questionTextElement.style.cursor = 'pointer';
                questionTextElement.title = 'クリックして例文を表示/非表示';

                questionTextElement.onclick = () => {
                    // 如果是历史题目，或者已经选择了答案（在提交前），则不允许切换例文显示
                    const isViewingPast = optionElements.length > 0 && optionElements[0].disabled;
                    if (selectedAnswer !== null && !isViewingPast) return;

                    if (!exampleSentenceDisplayElement.classList.contains('visible')) {
                        exampleSentenceDisplayElement.textContent = question.vocab.e;
                        exampleSentenceDisplayElement.classList.add('visible');
                    } else {
                        exampleSentenceDisplayElement.classList.remove('visible');
                    }
                };
            }
        }

        function updateTimer() {
            clearInterval(timerInterval);
            // 仅当不是查看历史答案，且测验未结束，且未选择答案时才启动计时器
            const isViewingPastAnswer = currentQuestion < maxQuestionReachedInSession && answerLog.find(log => log.questionIndex === currentQuestion);

            if (currentQuestion >= currentQuiz.length || selectedAnswer !== null || isViewingPastAnswer) {
                return;
            }

            const timerElement = document.getElementById('timer');
            if (timerElement && questionStartTime) {
                const update = () => {
                    const isStillViewingPastAnswer = currentQuestion < maxQuestionReachedInSession && answerLog.find(log => log.questionIndex === currentQuestion);
                    if (selectedAnswer !== null || currentQuestion >= currentQuiz.length || isStillViewingPastAnswer) {
                        clearInterval(timerInterval);
                        return;
                    }
                    const elapsed = Math.floor((Date.now() - questionStartTime) / 1000);
                    timerElement.textContent = elapsed;
                };
                update(); // Initial call
                timerInterval = setInterval(update, 1000);
            }
        }

        function selectAnswer(index) {
            const optionButton = document.querySelectorAll('.option')[index];
            if (selectedAnswer !== null || (optionButton && optionButton.disabled)) { // 如果已选择或按钮禁用
                return;
            }
            selectedAnswer = index;
            clearInterval(timerInterval); // 暂停计时器

            const exampleSentenceDisplayElement = document.getElementById('exampleSentenceDisplay');
            if (exampleSentenceDisplayElement) {
                exampleSentenceDisplayElement.classList.remove('visible');
            }

            document.querySelectorAll('.option').forEach((optionEl, i) => {
                optionEl.classList.remove('selected-option');
                optionEl.classList.remove('bg-gradient-to-br', 'from-indigo-500', 'to-purple-600', 'text-white', 'border-indigo-500');
                optionEl.style.borderColor = '';

                if (i === index) {
                    optionEl.classList.add('selected-option');
                    optionEl.classList.add('bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white');
                    optionEl.style.borderColor = isDarkMode ? '#a78bfa' : '#818cf8';
                }
            });
            setTimeout(() => { submitAnswer(); }, 100);
        }

        function submitAnswer() {
            if (selectedAnswer === null) return;

            // 防止重复提交或在查看历史时提交
            const optionButton = document.querySelectorAll('.option')[selectedAnswer];
            if (optionButton && optionButton.disabled) {
                selectedAnswer = null; // 重置selectedAnswer，因为这是无效提交
                return;
            }


            document.querySelectorAll('.option').forEach(optionEl => {
                optionEl.classList.remove('selected-option');
                optionEl.classList.remove('bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white');
                optionEl.style.borderColor = '';
            });

            const question = currentQuiz[currentQuestion];
            const isCorrect = question.options[selectedAnswer].correct;
            const timeSpent = Math.floor((Date.now() - questionStartTime) / 1000);
            totalTime += timeSpent;

            // --- 新增: 记录到 answerLog ---
            answerLog.push({
                questionIndex: currentQuestion,
                selectedOptionIndex: selectedAnswer,
                isCorrect: isCorrect,
                timeSpent: timeSpent,
                // vocab: question.vocab, // 可选，如果showQuestion中需要更多vocab信息
                // correctAnswerText: question.correctAnswer // 可选
            });
            // --- 结束 ---

            if (isCorrect) {
                score++;
                streak++;
                if (streak > maxStreak) maxStreak = streak;
            } else {
                streak = 0;
                wrongAnswers.push({
                    question: question.question,
                    yourAnswer: question.options[selectedAnswer].text,
                    correctAnswer: question.correctAnswer,
                    questionNumber: currentQuestion + 1,
                    vocab: question.vocab,
                    timeSpent: timeSpent,
                    mode: question.mode
                });
            }

            document.querySelectorAll('.option').forEach((option, i) => {
                option.disabled = true; // 提交后禁用选项
                if (question.options[i].correct) {
                    option.classList.add('bg-gradient-to-br', 'from-green-500', 'to-lime-600', 'text-white', 'border-green-500');
                } else if (i === selectedAnswer && !isCorrect) {
                    option.classList.add('bg-gradient-to-br', 'from-red-500', 'to-orange-500', 'text-white', 'border-red-500', 'animate-[incorrectShake_0.3s_ease]');
                }
                // option.style.pointerEvents = 'none'; // 使用 disabled 属性更好
            });

            const feedbackElement = document.querySelector('.feedback');
            feedbackElement.className = `feedback text-center text-lg md:text-xl font-semibold p-3 md:p-4 rounded-lg ${isCorrect ? 'text-green-600 bg-green-50 border-2 border-green-200' : 'text-red-600 bg-red-50 border-2 border-red-200'}`;
            if (isDarkMode) {
                if (isCorrect) feedbackElement.classList.add('dark:bg-green-900', 'dark:bg-opacity-30', 'dark:border-green-700');
                else feedbackElement.classList.add('dark:bg-red-900', 'dark:bg-opacity-30', 'dark:border-red-700');
            }


            let feedbackText = isCorrect ? `🎉 正解！ (${timeSpent}秒)` : `❌ 不正解。正解は“${question.correctAnswer}”。`;
            if (!isCorrect && question.vocab) {
                const displayMeaning = question.vocab.c || question.vocab.m;
                feedbackText += `<br><small class="text-gray-600 dark:text-slate-400 opacity-90 dark:opacity-85 text-sm md:text-base">
                ${question.vocab.w} ${question.vocab.w !== question.vocab.r ? '(' + question.vocab.r + ')' : ''} - ${displayMeaning}
            </small>`;
            }
            feedbackElement.innerHTML = feedbackText;

            if (feedbackElement) {
                feedbackElement.style.visibility = 'visible';
            }

            const delay = isCorrect ? 500 : 1200;
            setTimeout(() => {
                nextQuestion();
            }, delay);
        }

        function nextQuestion() {
            currentQuestion++;
            selectedAnswer = null;

            // --- 修改: 更新 maxQuestionReachedInSession ---
            // 如果进入的是一道全新的题（索引大于之前记录的最大索引）
            if (currentQuestion > maxQuestionReachedInSession) {
                maxQuestionReachedInSession = currentQuestion;
            }
            // --- 修改结束 ---

            showQuestion();
        }

        function resetQuizInterface() {
            if (headerElement) headerElement.classList.remove('hidden-during-quiz');
            if (controlsElement) controlsElement.classList.remove('hidden-during-quiz');
            document.body.classList.remove('quiz-mode-active');
            if (quizContainerElement) {
                quizContainerElement.classList.remove('immersive-active');
                quizContainerElement.style.paddingTop = '';
                quizContainerElement.style.paddingBottom = '';
                quizContainerElement.style.paddingLeft = '';
                quizContainerElement.style.paddingRight = '';
            }
            // --- 新增: 移除滑动监听器 ---
            if (quizContainerElement) {
                quizContainerElement.removeEventListener('touchstart', handleTouchStart);
                quizContainerElement.removeEventListener('touchmove', handleTouchMove);
                quizContainerElement.removeEventListener('touchend', handleTouchEnd);
            }
            // --- 移除监听器结束 ---
        }

        function showFinalScore() {
            resetQuizInterface(); // resetQuizInterface 内部会移除监听器
            clearInterval(timerInterval);
            totalTime = Math.floor((Date.now() - startTime) / 1000);
            const percentage = currentQuiz.length > 0 ? Math.round((score / currentQuiz.length) * 100) : 0;
            const avgTime = currentQuiz.length > 0 ? Math.round(totalTime / currentQuiz.length) : 0;

            let message = '';
            let emoji = '';
            if (percentage >= 90) {
                message = '素晴らしい！';
                emoji = '🏆';
            } else if (percentage >= 70) {
                message = 'よくできました！';
                emoji = '🎉';
            } else if (percentage >= 50) {
                message = 'もう少し頑張りましょう。';
                emoji = '💪';
            } else {
                message = '復習が必要です。';
                emoji = '📚';
            }

            let wrongAnswersHtml = '';
            if (wrongAnswers.length > 0) {
                wrongAnswersHtml = `
                <div class="wrong-answers-section mt-8 text-left animate-[slideUp_0.8s_ease]">
                    <h3 class="text-center text-2xl font-bold mb-5 text-red-600">${emoji} 復習が必要な単語 (${wrongAnswers.length}個)</h3>
                    <div class="wrong-answers-list max-h-80 overflow-y-auto bg-red-50 dark:bg-red-900 dark:bg-opacity-30 rounded-lg p-5 border border-red-200 dark:border-red-700">
                        ${wrongAnswers.map(wrong => `
                            <div class="wrong-answer-item mb-4 p-4 bg-white dark:bg-gray-700 rounded-lg border-l-4 border-red-500 shadow-md transition-transform duration-200 hover:translate-x-1">
                                <div class="font-bold mb-2 text-gray-900 dark:text-gray-100 text-lg">問題${wrong.questionNumber}: ${wrong.question}</div>
                                <div class="text-red-600 dark:text-red-400 mb-1 flex items-center gap-2">❌ あなたの回答: ${wrong.yourAnswer} <span class="bg-red-500 text-white py-0.5 px-2 rounded-full text-xs">${wrong.timeSpent}秒</span></div>
                                <div class="text-green-600 dark:text-green-400 mb-2">✅ 正解: ${wrong.correctAnswer}</div>
                                ${wrong.vocab ? `<div class="bg-indigo-100 dark:bg-indigo-900 dark:bg-opacity-40 p-2 rounded-md text-sm text-gray-700 dark:text-gray-300">
                                    <strong>${wrong.vocab.w}</strong> ${wrong.vocab.w !== wrong.vocab.r ? '(' + wrong.vocab.r + ')' : ''}<br>
                                    意味: ${wrong.vocab.c || wrong.vocab.m}<br>
                                    元々の例文: ${wrong.vocab.u || 'なし'}<br>
                                    ${wrong.vocab.e ? `収録例文: ${wrong.vocab.e}<br>` : ''}
                                    <button class="generate-sentence-btn mt-2 px-3 py-1.5 bg-blue-500 text-white text-sm rounded-full hover:bg-blue-600 transition-colors duration-200" onclick="generateExampleSentence(this, '${wrong.vocab.w.replace(/'/g, "\\'")}', '${wrong.vocab.r.replace(/'/g, "\\'")}', '${(wrong.vocab.c || wrong.vocab.m).replace(/'/g, "\\'")}')">✨ 新しい例文を生成</button>
                                </div>` : ''}
                            </div>`).join('')}
                    </div>
                </div>`;
            }

            quizContainerElement.innerHTML = `
            <div class="final-score text-center text-gray-900 dark:text-gray-100 text-3xl font-bold my-8 animate-[fadeIn_1s_ease]">
                <h2 class="text-4xl">${emoji} ${message}</h2>
                <div class="text-indigo-600 dark:text-indigo-400 my-5 text-2xl">${score} / ${currentQuiz.length} 正解</div>
                <div class="text-gray-600 dark:text-gray-400 text-xl mb-5">正答率: ${percentage}%</div>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 my-8 text-base">
                    <div class="bg-green-50 dark:bg-green-900 dark:bg-opacity-30 p-4 rounded-lg text-center"><div class="text-green-600 dark:text-green-400 font-bold">🔥 最高連続正解</div><div class="text-2xl font-bold">${maxStreak}</div></div>
                    <div class="bg-orange-50 dark:bg-orange-900 dark:bg-opacity-30 p-4 rounded-lg text-center"><div class="text-orange-600 dark:text-orange-400 font-bold">⏱️ 総時間</div><div class="text-2xl font-bold">${Math.floor(totalTime / 60)}:${(totalTime % 60).toString().padStart(2, '0')}</div></div>
                    <div class="bg-indigo-50 dark:bg-indigo-900 dark:bg-opacity-30 p-4 rounded-lg text-center"><div class="text-indigo-600 dark:text-indigo-400 font-bold">📊 平均時間</div><div class="text-2xl font-bold">${avgTime}秒</div></div>
                </div>
                ${wrongAnswersHtml}
                <div class="flex gap-4 justify-center mt-8 flex-wrap">
                    <button class="btn relative overflow-hidden bg-gradient-to-br from-indigo-500 to-purple-600 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0" onclick="startQuiz()">もう一度</button>
                    <button class="btn secondary relative overflow-hidden bg-gradient-to-br from-red-500 to-orange-500 text-white font-semibold py-3 px-6 rounded-full cursor-pointer text-base shadow-lg transition-all duration-300 hover:translate-y-[-2px] hover:shadow-xl active:translate-y-0 ${wrongAnswers.length === 0 ? 'opacity-50 cursor-not-allowed' : ''}" onclick="reviewWrongAnswers()" ${wrongAnswers.length === 0 ? 'disabled' : ''}>復習モード</button>
                </div>
            </div>`;
        }

        function reviewWrongAnswers() {
            if (wrongAnswers.length === 0) {
                showMessageBox('復習する問題がありません！');
                return;
            }

            if (headerElement) headerElement.classList.add('hidden-during-quiz');
            if (controlsElement) controlsElement.classList.add('hidden-during-quiz');
            document.body.classList.add('quiz-mode-active');
            if (quizContainerElement) quizContainerElement.classList.add('immersive-active');

            let allCombinedVocab = [];
            for (const lessonKey in allVocabulary) {
                if (allVocabulary.hasOwnProperty(lessonKey) && Array.isArray(allVocabulary[lessonKey])) {
                    allCombinedVocab = allCombinedVocab.concat(allVocabulary[lessonKey]);
                }
            }
            if (allCombinedVocab.length === 0) {
                allCombinedVocab = wrongAnswers.map(w => w.vocab).filter(Boolean);
            }
            allCombinedVocab = allCombinedVocab.filter(item => typeof item === 'object' && item !== null && item.w);


            currentQuiz = wrongAnswers.map(wrong => {
                const vocab = wrong.vocab;
                if (!vocab || typeof vocab.w === 'undefined') {
                    console.error("Invalid vocab item in wrongAnswers:", wrong);
                    return null;
                }
                const modes = ['reading', 'meaning', 'usage'];
                const reviewMode = wrong.mode && modes.includes(wrong.mode) ? wrong.mode : modes[Math.floor(Math.random() * modes.length)];
                const vocabSourceForOptions = allCombinedVocab.length > 0 ? allCombinedVocab : [vocab];
                return generateQuestion(vocab, reviewMode, vocabSourceForOptions);
            }).filter(Boolean);


            if (currentQuiz.length === 0) {
                showMessageBox('復習問題の作成に失敗しました。');
                resetQuiz();
                return;
            }

            currentQuestion = 0;
            score = 0;
            streak = 0;
            maxStreak = 0;
            selectedAnswer = null;
            startTime = Date.now();
            totalTime = 0;
            wrongAnswers = [];

            // --- 新增: 初始化答题历史和最远进度 (复习模式) ---
            answerLog = [];
            maxQuestionReachedInSession = 0;
            // --- 结束 ---

            // --- 初始化滑动相关状态并添加监听器 (复习模式) ---
            touchstartX = 0;
            touchendX = 0;
            touchstartY = 0;
            touchendY = 0;
            if (quizContainerElement) {
                quizContainerElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                quizContainerElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                quizContainerElement.addEventListener('touchend', handleTouchEnd, { passive: false });
            }
            // --- 滑动功能初始化结束 ---

            showQuestion();
        }

        function resetQuiz() {
            resetQuizInterface(); // resetQuizInterface 内部会移除监听器
            clearInterval(timerInterval);
            quizContainerElement.innerHTML = `
            <div class="welcome-message">
                <h2 class="text-center text-2xl font-bold mb-5">練習モードを選んで開始してください</h2>
                <p class="text-center text-gray-600 dark:text-gray-300 text-lg mb-8">
                    <strong>読み方:</strong> 漢字の読みを選択<br>
                    <strong>意味:</strong> 単語の意味を選択<br>
                    <strong>使い方:</strong> 文脈に合う単語を選択<br>
                    <strong>ミックス:</strong> 全種類の問題をランダムに<br>
                </p>
                <div class="features glass-morphism mt-8 p-5 bg-indigo-100 dark:bg-indigo-900 dark:bg-opacity-40 rounded-xl">
                    <h3 class="text-center text-xl font-semibold mb-4 text-indigo-600 dark:text-indigo-400">✨ 新機能</h3>
                    <ul class="text-left text-gray-600 dark:text-gray-300 leading-relaxed list-none list-inside">
                        <li>🎯 問題数選択（5/10/30/全て）</li>
                        <li>🔥 連続正解カウンター</li>
                        <li>⏱️ 問題別タイマー</li>
                        <li>🌙 ダークモード対応</li>
                        <li>⌨️ キーボードショートカット</li>
                        <li>📱 完全レスポンシブ対応</li>
                        <li>📚 レッスン選択機能</li>
                        <li>🇨🇳 意味練習で中国語表示</li>
                        <li>✨ AIによる新しい例文生成</li>
                        <li>📖 問題文クリックで例文表示 (全モード対応)</li>
                        <li>👆 左右スワイプで问题切替 (モバイル)</li>
                    </ul>
                </div>
            </div>`;
            currentQuiz = [];
            currentQuestion = 0;
            score = 0;
            selectedAnswer = null;
            streak = 0;
            maxStreak = 0;
            startTime = null;
            questionStartTime = null;
            totalTime = 0;
            wrongAnswers = [];

            // --- 新增: 重置答题历史和最远进度 ---
            answerLog = [];
            maxQuestionReachedInSession = 0;
            // --- 结束 ---
        }

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            const body = document.body;
            const button = document.querySelector('.theme-toggle');
            if (isDarkMode) {
                body.classList.add('dark-mode');
                body.classList.remove('text-gray-800');
                button.textContent = '☀️';
            } else {
                body.classList.remove('dark-mode');
                body.classList.add('text-gray-800');
                button.textContent = '🌙';
            }
            // 如果在测验中切换主题，需要重新渲染当前问题以应用新样式
            // 并且要保留其当前状态（例如，如果是已回答的历史问题，则保持禁用和历史反馈）
            if (document.body.classList.contains('quiz-mode-active') && currentQuiz.length > 0 && currentQuestion < currentQuiz.length) {
                // selectedAnswer 状态会在 showQuestion 中根据 historyEntry 决定是否重置或使用
                // 因此，直接调用 showQuestion 即可
                const tempSelected = selectedAnswer;
                const tempCurrentQ = currentQuestion;

                showQuestion(); // This will use answerLog to restore state if it's a past question

                // If it was an active question and an answer was selected (but not submitted), restore that temporary selection visual
                const isViewingPast = answerLog.find(log => log.questionIndex === tempCurrentQ);
                if (!isViewingPast && tempSelected !== null) {
                    selectedAnswer = tempSelected; // Restore for visual consistency before submission
                    const options = document.querySelectorAll('.option');
                    if (options[selectedAnswer] && !options[selectedAnswer].disabled) {
                        options[selectedAnswer].classList.add('selected-option');
                        options[selectedAnswer].classList.add('bg-gradient-to-br', 'from-indigo-400', 'to-purple-500', 'text-white');
                        options[selectedAnswer].style.borderColor = isDarkMode ? '#a78bfa' : '#818cf8';
                    }
                } else {
                    selectedAnswer = null; // Ensure selectedAnswer is null if viewing past or no selection was made
                }
            }
        }

        async function generateExampleSentence(buttonElement, word, reading, meaning) {
            buttonElement.disabled = true;
            buttonElement.textContent = '生成中...';
            showSentenceLoadingSpinner();

            let chatHistory = [{ role: "user", parts: [{ text: `「${word} (${reading})」という日本語の単語（意味：${meaning}）を使って、JLPT N3/N2レベルの自然な例文を一つ生成してください。**例文のみを日本語で提供し、説明や他のテキストは一切含めないでください。**` }] }];
            const payload = { contents: chatHistory };
            const apiKey = "YOUR_GEMINI_API_KEY"; // IMPORTANT: Replace with your actual API key

            if (apiKey === "YOUR_GEMINI_API_KEY" || apiKey === "") {
                showGeneratedSentenceModal('APIキーが設定されていません。');
                console.error('Gemini API key is not set.');
                buttonElement.disabled = false;
                buttonElement.innerHTML = '✨ 新しい例文を生成';
                const spinner = document.getElementById('sentenceLoadingSpinner');
                if (spinner) spinner.classList.add('hidden');
                return;
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorResult = await response.json().catch(() => ({ error: { message: 'Unknown API error format.' } }));
                    console.error('Gemini API error response:', errorResult);
                    throw new Error(`Gemini API request failed: ${response.status} ${response.statusText}. ${errorResult.error?.message || ''}`);
                }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const sentence = result.candidates[0].content.parts[0].text.trim();
                    showGeneratedSentenceModal(sentence);
                } else {
                    showGeneratedSentenceModal('例文の生成に失敗しました。APIからの応答形式が予期しないものです。');
                    console.error('Gemini API response structure unexpected:', result);
                }
            } catch (error) {
                showGeneratedSentenceModal(`例文の生成中にエラーが発生しました。`);
                console.error('Error calling Gemini API:', error);
            } finally {
                buttonElement.disabled = false;
                buttonElement.innerHTML = '✨ 新しい例文を生成';
            }
        }

        // --- 滑动处理函数 ---
        function handleTouchStart(event) {
            // 如果不是在答题模式，或者已经作答完毕等待下一题（selectedAnswer 不为 null 且不是历史查看），则不处理滑动
            const isViewingPastAnswer = currentQuestion < maxQuestionReachedInSession && answerLog.find(log => log.questionIndex === currentQuestion);
            if (!document.body.classList.contains('quiz-mode-active') || (selectedAnswer !== null && !isViewingPastAnswer) ) {
                return;
            }
            touchstartX = event.changedTouches[0].screenX;
            touchstartY = event.changedTouches[0].screenY;
        }

        function handleTouchMove(event) {
            const isViewingPastAnswer = currentQuestion < maxQuestionReachedInSession && answerLog.find(log => log.questionIndex === currentQuestion);
            if (!document.body.classList.contains('quiz-mode-active') || (selectedAnswer !== null && !isViewingPastAnswer) || touchstartX === 0) {
                return;
            }
            const currentX = event.changedTouches[0].screenX;
            const currentY = event.changedTouches[0].screenY;
            const deltaX = currentX - touchstartX;
            const deltaY = currentY - touchstartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                event.preventDefault();
            }
        }

        function handleTouchEnd(event) {
            const isViewingPastAnswer = currentQuestion < maxQuestionReachedInSession && answerLog.find(log => log.questionIndex === currentQuestion);
            if (!document.body.classList.contains('quiz-mode-active') || (selectedAnswer !== null && !isViewingPastAnswer) || touchstartX === 0) {
                return;
            }
            touchendX = event.changedTouches[0].screenX;
            touchendY = event.changedTouches[0].screenY;
            handleSwipeGesture();
            touchstartX = 0;
            touchstartY = 0;
        }

        function handleSwipeGesture() {
            const deltaX = touchendX - touchstartX;
            const deltaY = touchendY - touchstartY;

            if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX < 0) { // 向左滑动 (下一题)
                    if (currentQuestion < currentQuiz.length - 1) { // 确保不是最后一题
                        const targetQuestionIndex = currentQuestion + 1;
                        // 新增约束：只有当目标题目索引小于或等于已达到的最远题目索引时，才允许向前滑动
                        if (targetQuestionIndex <= maxQuestionReachedInSession) {
                            currentQuestion = targetQuestionIndex;
                            selectedAnswer = null;
                            showQuestion();
                        }
                        // 如果 targetQuestionIndex > maxQuestionReachedInSession，则滑动被阻止，用户不能跳过当前应答题目
                    }
                } else if (deltaX > 0) { // 向右滑动 (上一题)
                    if (currentQuestion > 0) { // 确保不是第一题
                        currentQuestion--;
                        selectedAnswer = null;
                        showQuestion();
                    }
                }
            }
        }
        // --- 滑动处理函数结束 ---
    </script>

</body>

</html>